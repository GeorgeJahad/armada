// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: internal/events/events.proto

package events

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	v1 "k8s.io/api/core/v1"
	v1beta1 "k8s.io/api/networking/v1beta1"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Message representing a sequence of state transitions.
// This is the only message type that should ever be published to the log.
type EventSequence struct {
	// The system is namespaced by queue, and all events are associated with a job set.
	// Hence, these are included with every message.
	Queue string `protobuf:"bytes,1,opt,name=queue,proto3" json:"queue,omitempty"`
	// Each job set has a unique name, which is namespaced by queue.
	// If job_set_name has been published to the log previously, then
	// then job_set_name can be omitted in favor of job_set_hash, which is the sha256 checksum of job_set_name.
	// This is to reduce message size and improve query performance.
	// The subscriber is responsible for storing previously seen values of job_set_name
	// and looking those up based on their hash (i.e., content-based addressing).
	JobSetName string `protobuf:"bytes,2,opt,name=job_set_name,json=jobSetName,proto3" json:"job_set_name,omitempty"`
	// job_set_hash is typically much shorter than job_set_name;
	// job_set_name is often a file path, which may have long common prefixes.
	JobSetHash []byte `protobuf:"bytes,3,opt,name=job_set_hash,json=jobSetHash,proto3" json:"job_set_hash,omitempty"`
	// Id of the user submitting the message. Is passed on to Kubernetes.
	UserId string `protobuf:"bytes,4,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	// List of groups the user is member of. Is passed on to Kubernetes.
	Groups []string `protobuf:"bytes,5,rep,name=groups,proto3" json:"groups,omitempty"`
	// For efficiency, we bundle several events (i.e., state transitions) in a single log message.
	Events []*EventSequence_Event `protobuf:"bytes,6,rep,name=events,proto3" json:"events,omitempty"`
}

func (m *EventSequence) Reset()         { *m = EventSequence{} }
func (m *EventSequence) String() string { return proto.CompactTextString(m) }
func (*EventSequence) ProtoMessage()    {}
func (*EventSequence) Descriptor() ([]byte, []int) {
	return fileDescriptor_a7740d41e030ef3b, []int{0}
}
func (m *EventSequence) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSequence) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSequence.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSequence) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSequence.Merge(m, src)
}
func (m *EventSequence) XXX_Size() int {
	return m.Size()
}
func (m *EventSequence) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSequence.DiscardUnknown(m)
}

var xxx_messageInfo_EventSequence proto.InternalMessageInfo

func (m *EventSequence) GetQueue() string {
	if m != nil {
		return m.Queue
	}
	return ""
}

func (m *EventSequence) GetJobSetName() string {
	if m != nil {
		return m.JobSetName
	}
	return ""
}

func (m *EventSequence) GetJobSetHash() []byte {
	if m != nil {
		return m.JobSetHash
	}
	return nil
}

func (m *EventSequence) GetUserId() string {
	if m != nil {
		return m.UserId
	}
	return ""
}

func (m *EventSequence) GetGroups() []string {
	if m != nil {
		return m.Groups
	}
	return nil
}

func (m *EventSequence) GetEvents() []*EventSequence_Event {
	if m != nil {
		return m.Events
	}
	return nil
}

// List of possible events, i.e., state transitions.
type EventSequence_Event struct {
	// Types that are valid to be assigned to Event:
	//	*EventSequence_Event_SubmitJob
	//	*EventSequence_Event_ReprioritiseJob
	//	*EventSequence_Event_ReprioritiseJobSet
	//	*EventSequence_Event_CancelJob
	//	*EventSequence_Event_CancelJobSet
	//	*EventSequence_Event_JobSucceeded
	//	*EventSequence_Event_JobFailed
	//	*EventSequence_Event_JobRejected
	//	*EventSequence_Event_JobRunLeased
	//	*EventSequence_Event_JobRunAssigned
	//	*EventSequence_Event_JobRunRunning
	//	*EventSequence_Event_JobRunReturned
	//	*EventSequence_Event_JobRunSucceeded
	//	*EventSequence_Event_JobRunFailed
	Event isEventSequence_Event_Event `protobuf_oneof:"event"`
}

func (m *EventSequence_Event) Reset()         { *m = EventSequence_Event{} }
func (m *EventSequence_Event) String() string { return proto.CompactTextString(m) }
func (*EventSequence_Event) ProtoMessage()    {}
func (*EventSequence_Event) Descriptor() ([]byte, []int) {
	return fileDescriptor_a7740d41e030ef3b, []int{0, 0}
}
func (m *EventSequence_Event) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSequence_Event) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSequence_Event.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSequence_Event) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSequence_Event.Merge(m, src)
}
func (m *EventSequence_Event) XXX_Size() int {
	return m.Size()
}
func (m *EventSequence_Event) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSequence_Event.DiscardUnknown(m)
}

var xxx_messageInfo_EventSequence_Event proto.InternalMessageInfo

type isEventSequence_Event_Event interface {
	isEventSequence_Event_Event()
	MarshalTo([]byte) (int, error)
	Size() int
}

type EventSequence_Event_SubmitJob struct {
	SubmitJob *SubmitJob `protobuf:"bytes,1,opt,name=submitJob,proto3,oneof" json:"submitJob,omitempty"`
}
type EventSequence_Event_ReprioritiseJob struct {
	ReprioritiseJob *ReprioritiseJob `protobuf:"bytes,2,opt,name=reprioritiseJob,proto3,oneof" json:"reprioritiseJob,omitempty"`
}
type EventSequence_Event_ReprioritiseJobSet struct {
	ReprioritiseJobSet *ReprioritiseJobSet `protobuf:"bytes,3,opt,name=reprioritiseJobSet,proto3,oneof" json:"reprioritiseJobSet,omitempty"`
}
type EventSequence_Event_CancelJob struct {
	CancelJob *CancelJob `protobuf:"bytes,4,opt,name=cancelJob,proto3,oneof" json:"cancelJob,omitempty"`
}
type EventSequence_Event_CancelJobSet struct {
	CancelJobSet *CancelJobSet `protobuf:"bytes,5,opt,name=cancelJobSet,proto3,oneof" json:"cancelJobSet,omitempty"`
}
type EventSequence_Event_JobSucceeded struct {
	JobSucceeded *JobSucceeded `protobuf:"bytes,6,opt,name=jobSucceeded,proto3,oneof" json:"jobSucceeded,omitempty"`
}
type EventSequence_Event_JobFailed struct {
	JobFailed *JobFailed `protobuf:"bytes,7,opt,name=jobFailed,proto3,oneof" json:"jobFailed,omitempty"`
}
type EventSequence_Event_JobRejected struct {
	JobRejected *JobRejected `protobuf:"bytes,8,opt,name=jobRejected,proto3,oneof" json:"jobRejected,omitempty"`
}
type EventSequence_Event_JobRunLeased struct {
	JobRunLeased *JobRunLeased `protobuf:"bytes,9,opt,name=jobRunLeased,proto3,oneof" json:"jobRunLeased,omitempty"`
}
type EventSequence_Event_JobRunAssigned struct {
	JobRunAssigned *JobRunAssigned `protobuf:"bytes,10,opt,name=jobRunAssigned,proto3,oneof" json:"jobRunAssigned,omitempty"`
}
type EventSequence_Event_JobRunRunning struct {
	JobRunRunning *JobRunRunning `protobuf:"bytes,11,opt,name=jobRunRunning,proto3,oneof" json:"jobRunRunning,omitempty"`
}
type EventSequence_Event_JobRunReturned struct {
	JobRunReturned *JobRunReturned `protobuf:"bytes,12,opt,name=jobRunReturned,proto3,oneof" json:"jobRunReturned,omitempty"`
}
type EventSequence_Event_JobRunSucceeded struct {
	JobRunSucceeded *JobRunSucceeded `protobuf:"bytes,13,opt,name=jobRunSucceeded,proto3,oneof" json:"jobRunSucceeded,omitempty"`
}
type EventSequence_Event_JobRunFailed struct {
	JobRunFailed *JobRunFailed `protobuf:"bytes,14,opt,name=jobRunFailed,proto3,oneof" json:"jobRunFailed,omitempty"`
}

func (*EventSequence_Event_SubmitJob) isEventSequence_Event_Event()          {}
func (*EventSequence_Event_ReprioritiseJob) isEventSequence_Event_Event()    {}
func (*EventSequence_Event_ReprioritiseJobSet) isEventSequence_Event_Event() {}
func (*EventSequence_Event_CancelJob) isEventSequence_Event_Event()          {}
func (*EventSequence_Event_CancelJobSet) isEventSequence_Event_Event()       {}
func (*EventSequence_Event_JobSucceeded) isEventSequence_Event_Event()       {}
func (*EventSequence_Event_JobFailed) isEventSequence_Event_Event()          {}
func (*EventSequence_Event_JobRejected) isEventSequence_Event_Event()        {}
func (*EventSequence_Event_JobRunLeased) isEventSequence_Event_Event()       {}
func (*EventSequence_Event_JobRunAssigned) isEventSequence_Event_Event()     {}
func (*EventSequence_Event_JobRunRunning) isEventSequence_Event_Event()      {}
func (*EventSequence_Event_JobRunReturned) isEventSequence_Event_Event()     {}
func (*EventSequence_Event_JobRunSucceeded) isEventSequence_Event_Event()    {}
func (*EventSequence_Event_JobRunFailed) isEventSequence_Event_Event()       {}

func (m *EventSequence_Event) GetEvent() isEventSequence_Event_Event {
	if m != nil {
		return m.Event
	}
	return nil
}

func (m *EventSequence_Event) GetSubmitJob() *SubmitJob {
	if x, ok := m.GetEvent().(*EventSequence_Event_SubmitJob); ok {
		return x.SubmitJob
	}
	return nil
}

func (m *EventSequence_Event) GetReprioritiseJob() *ReprioritiseJob {
	if x, ok := m.GetEvent().(*EventSequence_Event_ReprioritiseJob); ok {
		return x.ReprioritiseJob
	}
	return nil
}

func (m *EventSequence_Event) GetReprioritiseJobSet() *ReprioritiseJobSet {
	if x, ok := m.GetEvent().(*EventSequence_Event_ReprioritiseJobSet); ok {
		return x.ReprioritiseJobSet
	}
	return nil
}

func (m *EventSequence_Event) GetCancelJob() *CancelJob {
	if x, ok := m.GetEvent().(*EventSequence_Event_CancelJob); ok {
		return x.CancelJob
	}
	return nil
}

func (m *EventSequence_Event) GetCancelJobSet() *CancelJobSet {
	if x, ok := m.GetEvent().(*EventSequence_Event_CancelJobSet); ok {
		return x.CancelJobSet
	}
	return nil
}

func (m *EventSequence_Event) GetJobSucceeded() *JobSucceeded {
	if x, ok := m.GetEvent().(*EventSequence_Event_JobSucceeded); ok {
		return x.JobSucceeded
	}
	return nil
}

func (m *EventSequence_Event) GetJobFailed() *JobFailed {
	if x, ok := m.GetEvent().(*EventSequence_Event_JobFailed); ok {
		return x.JobFailed
	}
	return nil
}

func (m *EventSequence_Event) GetJobRejected() *JobRejected {
	if x, ok := m.GetEvent().(*EventSequence_Event_JobRejected); ok {
		return x.JobRejected
	}
	return nil
}

func (m *EventSequence_Event) GetJobRunLeased() *JobRunLeased {
	if x, ok := m.GetEvent().(*EventSequence_Event_JobRunLeased); ok {
		return x.JobRunLeased
	}
	return nil
}

func (m *EventSequence_Event) GetJobRunAssigned() *JobRunAssigned {
	if x, ok := m.GetEvent().(*EventSequence_Event_JobRunAssigned); ok {
		return x.JobRunAssigned
	}
	return nil
}

func (m *EventSequence_Event) GetJobRunRunning() *JobRunRunning {
	if x, ok := m.GetEvent().(*EventSequence_Event_JobRunRunning); ok {
		return x.JobRunRunning
	}
	return nil
}

func (m *EventSequence_Event) GetJobRunReturned() *JobRunReturned {
	if x, ok := m.GetEvent().(*EventSequence_Event_JobRunReturned); ok {
		return x.JobRunReturned
	}
	return nil
}

func (m *EventSequence_Event) GetJobRunSucceeded() *JobRunSucceeded {
	if x, ok := m.GetEvent().(*EventSequence_Event_JobRunSucceeded); ok {
		return x.JobRunSucceeded
	}
	return nil
}

func (m *EventSequence_Event) GetJobRunFailed() *JobRunFailed {
	if x, ok := m.GetEvent().(*EventSequence_Event_JobRunFailed); ok {
		return x.JobRunFailed
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*EventSequence_Event) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*EventSequence_Event_SubmitJob)(nil),
		(*EventSequence_Event_ReprioritiseJob)(nil),
		(*EventSequence_Event_ReprioritiseJobSet)(nil),
		(*EventSequence_Event_CancelJob)(nil),
		(*EventSequence_Event_CancelJobSet)(nil),
		(*EventSequence_Event_JobSucceeded)(nil),
		(*EventSequence_Event_JobFailed)(nil),
		(*EventSequence_Event_JobRejected)(nil),
		(*EventSequence_Event_JobRunLeased)(nil),
		(*EventSequence_Event_JobRunAssigned)(nil),
		(*EventSequence_Event_JobRunRunning)(nil),
		(*EventSequence_Event_JobRunReturned)(nil),
		(*EventSequence_Event_JobRunSucceeded)(nil),
		(*EventSequence_Event_JobRunFailed)(nil),
	}
}

// A request to run an Armada job. Each job consists of a set of Kubernetes objects,
// one of which is the main object (typically a pod spec.) and has a priority associated with it
// When the main object exists, all other objects are cleaned up.
// The priority, together with the queue the job is submitted to, determines the order in which job are run.
type SubmitJob struct {
	// Each application may be run multiple times. This id uniquely identifies this job.
	JobId string `protobuf:"bytes,1,opt,name=job_id,json=jobId,proto3" json:"job_id,omitempty"`
	// User-provided id used for server-side deduplication.
	// I.e., jobs submitted with the same deduplication_id as an existing job are discarded.
	// TODO: If we can deduplicate at the API endpoint, we don't need this on the log.
	DeduplicationId string `protobuf:"bytes,2,opt,name=deduplication_id,json=deduplicationId,proto3" json:"deduplication_id,omitempty"`
	// Priority of this job. Measured relative to other jobs in the same queue.
	Priority float64 `protobuf:"fixed64,3,opt,name=priority,proto3" json:"priority,omitempty"`
	// If true, the job is run at most once, i.e., it will be leased at most once, and will not be preempted.
	// If false, the job may be re-leased on failure, which may cause the job to run more than once
	// (e.g., if a job run succeeds but the executor fails before it can report job success).
	// In addition, non-fragile jobs may be preempted.
	Fragile bool `protobuf:"varint,4,opt,name=fragile,proto3" json:"fragile,omitempty"`
	// Information about how the job should be run in Kubernetes.
	// Is applied to the main object and any additional objects that do not contain a separate ObjectMeta object.
	ObjectMeta *ObjectMeta `protobuf:"bytes,5,opt,name=objectMeta,proto3" json:"objectMeta,omitempty"`
	// Main object that determines when an application has finished.
	MainObject *KubernetesMainObject `protobuf:"bytes,6,opt,name=mainObject,proto3" json:"mainObject,omitempty"`
	// Set of additional Kubernetes objects to create as part of the job.
	Objects []*KubernetesObject `protobuf:"bytes,7,rep,name=objects,proto3" json:"objects,omitempty"`
}

func (m *SubmitJob) Reset()         { *m = SubmitJob{} }
func (m *SubmitJob) String() string { return proto.CompactTextString(m) }
func (*SubmitJob) ProtoMessage()    {}
func (*SubmitJob) Descriptor() ([]byte, []int) {
	return fileDescriptor_a7740d41e030ef3b, []int{1}
}
func (m *SubmitJob) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubmitJob) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubmitJob.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubmitJob) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubmitJob.Merge(m, src)
}
func (m *SubmitJob) XXX_Size() int {
	return m.Size()
}
func (m *SubmitJob) XXX_DiscardUnknown() {
	xxx_messageInfo_SubmitJob.DiscardUnknown(m)
}

var xxx_messageInfo_SubmitJob proto.InternalMessageInfo

func (m *SubmitJob) GetJobId() string {
	if m != nil {
		return m.JobId
	}
	return ""
}

func (m *SubmitJob) GetDeduplicationId() string {
	if m != nil {
		return m.DeduplicationId
	}
	return ""
}

func (m *SubmitJob) GetPriority() float64 {
	if m != nil {
		return m.Priority
	}
	return 0
}

func (m *SubmitJob) GetFragile() bool {
	if m != nil {
		return m.Fragile
	}
	return false
}

func (m *SubmitJob) GetObjectMeta() *ObjectMeta {
	if m != nil {
		return m.ObjectMeta
	}
	return nil
}

func (m *SubmitJob) GetMainObject() *KubernetesMainObject {
	if m != nil {
		return m.MainObject
	}
	return nil
}

func (m *SubmitJob) GetObjects() []*KubernetesObject {
	if m != nil {
		return m.Objects
	}
	return nil
}

// Kubernetes objects that can serve as main objects for an Armada job.
type KubernetesMainObject struct {
	// Types that are valid to be assigned to Object:
	//	*KubernetesMainObject_PodSpec
	Object isKubernetesMainObject_Object `protobuf_oneof:"object"`
}

func (m *KubernetesMainObject) Reset()         { *m = KubernetesMainObject{} }
func (m *KubernetesMainObject) String() string { return proto.CompactTextString(m) }
func (*KubernetesMainObject) ProtoMessage()    {}
func (*KubernetesMainObject) Descriptor() ([]byte, []int) {
	return fileDescriptor_a7740d41e030ef3b, []int{2}
}
func (m *KubernetesMainObject) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KubernetesMainObject) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KubernetesMainObject.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KubernetesMainObject) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KubernetesMainObject.Merge(m, src)
}
func (m *KubernetesMainObject) XXX_Size() int {
	return m.Size()
}
func (m *KubernetesMainObject) XXX_DiscardUnknown() {
	xxx_messageInfo_KubernetesMainObject.DiscardUnknown(m)
}

var xxx_messageInfo_KubernetesMainObject proto.InternalMessageInfo

type isKubernetesMainObject_Object interface {
	isKubernetesMainObject_Object()
	MarshalTo([]byte) (int, error)
	Size() int
}

type KubernetesMainObject_PodSpec struct {
	PodSpec *PodSpecWithAvoidList `protobuf:"bytes,1,opt,name=pod_spec,json=podSpec,proto3,oneof" json:"pod_spec,omitempty"`
}

func (*KubernetesMainObject_PodSpec) isKubernetesMainObject_Object() {}

func (m *KubernetesMainObject) GetObject() isKubernetesMainObject_Object {
	if m != nil {
		return m.Object
	}
	return nil
}

func (m *KubernetesMainObject) GetPodSpec() *PodSpecWithAvoidList {
	if x, ok := m.GetObject().(*KubernetesMainObject_PodSpec); ok {
		return x.PodSpec
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*KubernetesMainObject) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*KubernetesMainObject_PodSpec)(nil),
	}
}

// Kubernetes objects that can be created as part of an Armada.
type KubernetesObject struct {
	ObjectMeta *ObjectMeta `protobuf:"bytes,1,opt,name=objectMeta,proto3" json:"objectMeta,omitempty"`
	// Types that are valid to be assigned to Object:
	//	*KubernetesObject_PodSpec
	//	*KubernetesObject_Ingress
	//	*KubernetesObject_Service
	//	*KubernetesObject_ConfigMap
	Object isKubernetesObject_Object `protobuf_oneof:"object"`
}

func (m *KubernetesObject) Reset()         { *m = KubernetesObject{} }
func (m *KubernetesObject) String() string { return proto.CompactTextString(m) }
func (*KubernetesObject) ProtoMessage()    {}
func (*KubernetesObject) Descriptor() ([]byte, []int) {
	return fileDescriptor_a7740d41e030ef3b, []int{3}
}
func (m *KubernetesObject) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KubernetesObject) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KubernetesObject.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KubernetesObject) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KubernetesObject.Merge(m, src)
}
func (m *KubernetesObject) XXX_Size() int {
	return m.Size()
}
func (m *KubernetesObject) XXX_DiscardUnknown() {
	xxx_messageInfo_KubernetesObject.DiscardUnknown(m)
}

var xxx_messageInfo_KubernetesObject proto.InternalMessageInfo

type isKubernetesObject_Object interface {
	isKubernetesObject_Object()
	MarshalTo([]byte) (int, error)
	Size() int
}

type KubernetesObject_PodSpec struct {
	PodSpec *PodSpecWithAvoidList `protobuf:"bytes,2,opt,name=pod_spec,json=podSpec,proto3,oneof" json:"pod_spec,omitempty"`
}
type KubernetesObject_Ingress struct {
	Ingress *v1beta1.IngressSpec `protobuf:"bytes,3,opt,name=ingress,proto3,oneof" json:"ingress,omitempty"`
}
type KubernetesObject_Service struct {
	Service *v1.ServiceSpec `protobuf:"bytes,4,opt,name=service,proto3,oneof" json:"service,omitempty"`
}
type KubernetesObject_ConfigMap struct {
	ConfigMap *v1.ConfigMap `protobuf:"bytes,5,opt,name=configMap,proto3,oneof" json:"configMap,omitempty"`
}

func (*KubernetesObject_PodSpec) isKubernetesObject_Object()   {}
func (*KubernetesObject_Ingress) isKubernetesObject_Object()   {}
func (*KubernetesObject_Service) isKubernetesObject_Object()   {}
func (*KubernetesObject_ConfigMap) isKubernetesObject_Object() {}

func (m *KubernetesObject) GetObject() isKubernetesObject_Object {
	if m != nil {
		return m.Object
	}
	return nil
}

func (m *KubernetesObject) GetObjectMeta() *ObjectMeta {
	if m != nil {
		return m.ObjectMeta
	}
	return nil
}

func (m *KubernetesObject) GetPodSpec() *PodSpecWithAvoidList {
	if x, ok := m.GetObject().(*KubernetesObject_PodSpec); ok {
		return x.PodSpec
	}
	return nil
}

func (m *KubernetesObject) GetIngress() *v1beta1.IngressSpec {
	if x, ok := m.GetObject().(*KubernetesObject_Ingress); ok {
		return x.Ingress
	}
	return nil
}

func (m *KubernetesObject) GetService() *v1.ServiceSpec {
	if x, ok := m.GetObject().(*KubernetesObject_Service); ok {
		return x.Service
	}
	return nil
}

func (m *KubernetesObject) GetConfigMap() *v1.ConfigMap {
	if x, ok := m.GetObject().(*KubernetesObject_ConfigMap); ok {
		return x.ConfigMap
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*KubernetesObject) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*KubernetesObject_PodSpec)(nil),
		(*KubernetesObject_Ingress)(nil),
		(*KubernetesObject_Service)(nil),
		(*KubernetesObject_ConfigMap)(nil),
	}
}

// Auxiliary information needed to instantiate the object in Kubernetes.
// Mirrors the Kubernetes ObjectMeta object.
type ObjectMeta struct {
	Namespace   string            `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	Annotations map[string]string `protobuf:"bytes,2,rep,name=annotations,proto3" json:"annotations,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Labels      map[string]string `protobuf:"bytes,3,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *ObjectMeta) Reset()         { *m = ObjectMeta{} }
func (m *ObjectMeta) String() string { return proto.CompactTextString(m) }
func (*ObjectMeta) ProtoMessage()    {}
func (*ObjectMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_a7740d41e030ef3b, []int{4}
}
func (m *ObjectMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ObjectMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ObjectMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ObjectMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ObjectMeta.Merge(m, src)
}
func (m *ObjectMeta) XXX_Size() int {
	return m.Size()
}
func (m *ObjectMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_ObjectMeta.DiscardUnknown(m)
}

var xxx_messageInfo_ObjectMeta proto.InternalMessageInfo

func (m *ObjectMeta) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *ObjectMeta) GetAnnotations() map[string]string {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *ObjectMeta) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

// Kubernetes pod spec. with a bundled list of pods to avoid scheduling the pod to.
type PodSpecWithAvoidList struct {
	PodSpec *v1.PodSpec `protobuf:"bytes,1,opt,name=pod_spec,json=podSpec,proto3" json:"pod_spec,omitempty"`
	// List of nodes to avoid scheduling this pod on.
	// TODO: Could this be done with selectors, taints, etc?
	NodeAvoidlist []string `protobuf:"bytes,2,rep,name=node_avoidlist,json=nodeAvoidlist,proto3" json:"node_avoidlist,omitempty"`
}

func (m *PodSpecWithAvoidList) Reset()         { *m = PodSpecWithAvoidList{} }
func (m *PodSpecWithAvoidList) String() string { return proto.CompactTextString(m) }
func (*PodSpecWithAvoidList) ProtoMessage()    {}
func (*PodSpecWithAvoidList) Descriptor() ([]byte, []int) {
	return fileDescriptor_a7740d41e030ef3b, []int{5}
}
func (m *PodSpecWithAvoidList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PodSpecWithAvoidList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PodSpecWithAvoidList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PodSpecWithAvoidList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PodSpecWithAvoidList.Merge(m, src)
}
func (m *PodSpecWithAvoidList) XXX_Size() int {
	return m.Size()
}
func (m *PodSpecWithAvoidList) XXX_DiscardUnknown() {
	xxx_messageInfo_PodSpecWithAvoidList.DiscardUnknown(m)
}

var xxx_messageInfo_PodSpecWithAvoidList proto.InternalMessageInfo

func (m *PodSpecWithAvoidList) GetPodSpec() *v1.PodSpec {
	if m != nil {
		return m.PodSpec
	}
	return nil
}

func (m *PodSpecWithAvoidList) GetNodeAvoidlist() []string {
	if m != nil {
		return m.NodeAvoidlist
	}
	return nil
}

// Set the priority of a particular job.
type ReprioritiseJob struct {
	JobId    string  `protobuf:"bytes,1,opt,name=job_id,json=jobId,proto3" json:"job_id,omitempty"`
	Priority float64 `protobuf:"fixed64,2,opt,name=priority,proto3" json:"priority,omitempty"`
}

func (m *ReprioritiseJob) Reset()         { *m = ReprioritiseJob{} }
func (m *ReprioritiseJob) String() string { return proto.CompactTextString(m) }
func (*ReprioritiseJob) ProtoMessage()    {}
func (*ReprioritiseJob) Descriptor() ([]byte, []int) {
	return fileDescriptor_a7740d41e030ef3b, []int{6}
}
func (m *ReprioritiseJob) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReprioritiseJob) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReprioritiseJob.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReprioritiseJob) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReprioritiseJob.Merge(m, src)
}
func (m *ReprioritiseJob) XXX_Size() int {
	return m.Size()
}
func (m *ReprioritiseJob) XXX_DiscardUnknown() {
	xxx_messageInfo_ReprioritiseJob.DiscardUnknown(m)
}

var xxx_messageInfo_ReprioritiseJob proto.InternalMessageInfo

func (m *ReprioritiseJob) GetJobId() string {
	if m != nil {
		return m.JobId
	}
	return ""
}

func (m *ReprioritiseJob) GetPriority() float64 {
	if m != nil {
		return m.Priority
	}
	return 0
}

// Set the priority of all jobs part of a job set.
// This sets the priority of all jobs in the job set currently in the queued state.
type ReprioritiseJobSet struct {
	Priority float64 `protobuf:"fixed64,1,opt,name=priority,proto3" json:"priority,omitempty"`
}

func (m *ReprioritiseJobSet) Reset()         { *m = ReprioritiseJobSet{} }
func (m *ReprioritiseJobSet) String() string { return proto.CompactTextString(m) }
func (*ReprioritiseJobSet) ProtoMessage()    {}
func (*ReprioritiseJobSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_a7740d41e030ef3b, []int{7}
}
func (m *ReprioritiseJobSet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReprioritiseJobSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReprioritiseJobSet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReprioritiseJobSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReprioritiseJobSet.Merge(m, src)
}
func (m *ReprioritiseJobSet) XXX_Size() int {
	return m.Size()
}
func (m *ReprioritiseJobSet) XXX_DiscardUnknown() {
	xxx_messageInfo_ReprioritiseJobSet.DiscardUnknown(m)
}

var xxx_messageInfo_ReprioritiseJobSet proto.InternalMessageInfo

func (m *ReprioritiseJobSet) GetPriority() float64 {
	if m != nil {
		return m.Priority
	}
	return 0
}

// A request to cancel a particular job.
// This will cancel all runs (preempting it if running) for the job (i.e., move them to the failed state)
// and then cancel job itself (i.e., move it to the failed state).
type CancelJob struct {
	JobId string `protobuf:"bytes,1,opt,name=job_id,json=jobId,proto3" json:"job_id,omitempty"`
}

func (m *CancelJob) Reset()         { *m = CancelJob{} }
func (m *CancelJob) String() string { return proto.CompactTextString(m) }
func (*CancelJob) ProtoMessage()    {}
func (*CancelJob) Descriptor() ([]byte, []int) {
	return fileDescriptor_a7740d41e030ef3b, []int{8}
}
func (m *CancelJob) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CancelJob) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CancelJob.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CancelJob) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CancelJob.Merge(m, src)
}
func (m *CancelJob) XXX_Size() int {
	return m.Size()
}
func (m *CancelJob) XXX_DiscardUnknown() {
	xxx_messageInfo_CancelJob.DiscardUnknown(m)
}

var xxx_messageInfo_CancelJob proto.InternalMessageInfo

func (m *CancelJob) GetJobId() string {
	if m != nil {
		return m.JobId
	}
	return ""
}

// Request to cancel all jobs in a job set.
type CancelJobSet struct {
}

func (m *CancelJobSet) Reset()         { *m = CancelJobSet{} }
func (m *CancelJobSet) String() string { return proto.CompactTextString(m) }
func (*CancelJobSet) ProtoMessage()    {}
func (*CancelJobSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_a7740d41e030ef3b, []int{9}
}
func (m *CancelJobSet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CancelJobSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CancelJobSet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CancelJobSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CancelJobSet.Merge(m, src)
}
func (m *CancelJobSet) XXX_Size() int {
	return m.Size()
}
func (m *CancelJobSet) XXX_DiscardUnknown() {
	xxx_messageInfo_CancelJobSet.DiscardUnknown(m)
}

var xxx_messageInfo_CancelJobSet proto.InternalMessageInfo

type JobSucceeded struct {
	JobId string `protobuf:"bytes,1,opt,name=job_id,json=jobId,proto3" json:"job_id,omitempty"`
}

func (m *JobSucceeded) Reset()         { *m = JobSucceeded{} }
func (m *JobSucceeded) String() string { return proto.CompactTextString(m) }
func (*JobSucceeded) ProtoMessage()    {}
func (*JobSucceeded) Descriptor() ([]byte, []int) {
	return fileDescriptor_a7740d41e030ef3b, []int{10}
}
func (m *JobSucceeded) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobSucceeded) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JobSucceeded.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JobSucceeded) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobSucceeded.Merge(m, src)
}
func (m *JobSucceeded) XXX_Size() int {
	return m.Size()
}
func (m *JobSucceeded) XXX_DiscardUnknown() {
	xxx_messageInfo_JobSucceeded.DiscardUnknown(m)
}

var xxx_messageInfo_JobSucceeded proto.InternalMessageInfo

func (m *JobSucceeded) GetJobId() string {
	if m != nil {
		return m.JobId
	}
	return ""
}

type JobFailed struct {
	JobId string `protobuf:"bytes,1,opt,name=job_id,json=jobId,proto3" json:"job_id,omitempty"`
	// Types that are valid to be assigned to Reason:
	//	*JobFailed_MaxRunsExceeded_
	Reason isJobFailed_Reason `protobuf_oneof:"reason"`
}

func (m *JobFailed) Reset()         { *m = JobFailed{} }
func (m *JobFailed) String() string { return proto.CompactTextString(m) }
func (*JobFailed) ProtoMessage()    {}
func (*JobFailed) Descriptor() ([]byte, []int) {
	return fileDescriptor_a7740d41e030ef3b, []int{11}
}
func (m *JobFailed) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobFailed) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JobFailed.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JobFailed) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobFailed.Merge(m, src)
}
func (m *JobFailed) XXX_Size() int {
	return m.Size()
}
func (m *JobFailed) XXX_DiscardUnknown() {
	xxx_messageInfo_JobFailed.DiscardUnknown(m)
}

var xxx_messageInfo_JobFailed proto.InternalMessageInfo

type isJobFailed_Reason interface {
	isJobFailed_Reason()
	MarshalTo([]byte) (int, error)
	Size() int
}

type JobFailed_MaxRunsExceeded_ struct {
	MaxRunsExceeded *JobFailed_MaxRunsExceeded `protobuf:"bytes,2,opt,name=maxRunsExceeded,proto3,oneof" json:"maxRunsExceeded,omitempty"`
}

func (*JobFailed_MaxRunsExceeded_) isJobFailed_Reason() {}

func (m *JobFailed) GetReason() isJobFailed_Reason {
	if m != nil {
		return m.Reason
	}
	return nil
}

func (m *JobFailed) GetJobId() string {
	if m != nil {
		return m.JobId
	}
	return ""
}

func (m *JobFailed) GetMaxRunsExceeded() *JobFailed_MaxRunsExceeded {
	if x, ok := m.GetReason().(*JobFailed_MaxRunsExceeded_); ok {
		return x.MaxRunsExceeded
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*JobFailed) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*JobFailed_MaxRunsExceeded_)(nil),
	}
}

type JobFailed_MaxRunsExceeded struct {
}

func (m *JobFailed_MaxRunsExceeded) Reset()         { *m = JobFailed_MaxRunsExceeded{} }
func (m *JobFailed_MaxRunsExceeded) String() string { return proto.CompactTextString(m) }
func (*JobFailed_MaxRunsExceeded) ProtoMessage()    {}
func (*JobFailed_MaxRunsExceeded) Descriptor() ([]byte, []int) {
	return fileDescriptor_a7740d41e030ef3b, []int{11, 0}
}
func (m *JobFailed_MaxRunsExceeded) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobFailed_MaxRunsExceeded) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JobFailed_MaxRunsExceeded.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JobFailed_MaxRunsExceeded) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobFailed_MaxRunsExceeded.Merge(m, src)
}
func (m *JobFailed_MaxRunsExceeded) XXX_Size() int {
	return m.Size()
}
func (m *JobFailed_MaxRunsExceeded) XXX_DiscardUnknown() {
	xxx_messageInfo_JobFailed_MaxRunsExceeded.DiscardUnknown(m)
}

var xxx_messageInfo_JobFailed_MaxRunsExceeded proto.InternalMessageInfo

// Generated if the a job is rejected, e.g., because it requested more resources than are available.
// A failed job is a job Armada tried to run, but which failed. Jobs are rejected if they can never be run.
type JobRejected struct {
	JobId string `protobuf:"bytes,1,opt,name=job_id,json=jobId,proto3" json:"job_id,omitempty"`
	// Types that are valid to be assigned to Reason:
	//	*JobRejected_JobUnschedulable_
	Reason isJobRejected_Reason `protobuf_oneof:"reason"`
}

func (m *JobRejected) Reset()         { *m = JobRejected{} }
func (m *JobRejected) String() string { return proto.CompactTextString(m) }
func (*JobRejected) ProtoMessage()    {}
func (*JobRejected) Descriptor() ([]byte, []int) {
	return fileDescriptor_a7740d41e030ef3b, []int{12}
}
func (m *JobRejected) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobRejected) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JobRejected.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JobRejected) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobRejected.Merge(m, src)
}
func (m *JobRejected) XXX_Size() int {
	return m.Size()
}
func (m *JobRejected) XXX_DiscardUnknown() {
	xxx_messageInfo_JobRejected.DiscardUnknown(m)
}

var xxx_messageInfo_JobRejected proto.InternalMessageInfo

type isJobRejected_Reason interface {
	isJobRejected_Reason()
	MarshalTo([]byte) (int, error)
	Size() int
}

type JobRejected_JobUnschedulable_ struct {
	JobUnschedulable *JobRejected_JobUnschedulable `protobuf:"bytes,2,opt,name=jobUnschedulable,proto3,oneof" json:"jobUnschedulable,omitempty"`
}

func (*JobRejected_JobUnschedulable_) isJobRejected_Reason() {}

func (m *JobRejected) GetReason() isJobRejected_Reason {
	if m != nil {
		return m.Reason
	}
	return nil
}

func (m *JobRejected) GetJobId() string {
	if m != nil {
		return m.JobId
	}
	return ""
}

func (m *JobRejected) GetJobUnschedulable() *JobRejected_JobUnschedulable {
	if x, ok := m.GetReason().(*JobRejected_JobUnschedulable_); ok {
		return x.JobUnschedulable
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*JobRejected) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*JobRejected_JobUnschedulable_)(nil),
	}
}

// TODO: Add details
type JobRejected_JobUnschedulable struct {
}

func (m *JobRejected_JobUnschedulable) Reset()         { *m = JobRejected_JobUnschedulable{} }
func (m *JobRejected_JobUnschedulable) String() string { return proto.CompactTextString(m) }
func (*JobRejected_JobUnschedulable) ProtoMessage()    {}
func (*JobRejected_JobUnschedulable) Descriptor() ([]byte, []int) {
	return fileDescriptor_a7740d41e030ef3b, []int{12, 0}
}
func (m *JobRejected_JobUnschedulable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobRejected_JobUnschedulable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JobRejected_JobUnschedulable.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JobRejected_JobUnschedulable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobRejected_JobUnschedulable.Merge(m, src)
}
func (m *JobRejected_JobUnschedulable) XXX_Size() int {
	return m.Size()
}
func (m *JobRejected_JobUnschedulable) XXX_DiscardUnknown() {
	xxx_messageInfo_JobRejected_JobUnschedulable.DiscardUnknown(m)
}

var xxx_messageInfo_JobRejected_JobUnschedulable proto.InternalMessageInfo

// Indicates that a job has been leased to a cluster by the Armada scheduler.
type JobRunLeased struct {
	RunId string `protobuf:"bytes,1,opt,name=run_id,json=runId,proto3" json:"run_id,omitempty"`
	JobId string `protobuf:"bytes,2,opt,name=job_id,json=jobId,proto3" json:"job_id,omitempty"`
	// Each cluster is represented by an executor.
	ExecutorId string `protobuf:"bytes,3,opt,name=executor_id,json=executorId,proto3" json:"executor_id,omitempty"`
}

func (m *JobRunLeased) Reset()         { *m = JobRunLeased{} }
func (m *JobRunLeased) String() string { return proto.CompactTextString(m) }
func (*JobRunLeased) ProtoMessage()    {}
func (*JobRunLeased) Descriptor() ([]byte, []int) {
	return fileDescriptor_a7740d41e030ef3b, []int{13}
}
func (m *JobRunLeased) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobRunLeased) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JobRunLeased.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JobRunLeased) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobRunLeased.Merge(m, src)
}
func (m *JobRunLeased) XXX_Size() int {
	return m.Size()
}
func (m *JobRunLeased) XXX_DiscardUnknown() {
	xxx_messageInfo_JobRunLeased.DiscardUnknown(m)
}

var xxx_messageInfo_JobRunLeased proto.InternalMessageInfo

func (m *JobRunLeased) GetRunId() string {
	if m != nil {
		return m.RunId
	}
	return ""
}

func (m *JobRunLeased) GetJobId() string {
	if m != nil {
		return m.JobId
	}
	return ""
}

func (m *JobRunLeased) GetExecutorId() string {
	if m != nil {
		return m.ExecutorId
	}
	return ""
}

// Indicates that a job has been leased to a cluster by the Armada scheduler.
type JobRunAssigned struct {
	RunId string `protobuf:"bytes,1,opt,name=run_id,json=runId,proto3" json:"run_id,omitempty"`
	JobId string `protobuf:"bytes,2,opt,name=job_id,json=jobId,proto3" json:"job_id,omitempty"`
	// Runtime information, e.g., which pod the job is running on, its IP address etc.
	//
	// Types that are valid to be assigned to RunInfo:
	//	*JobRunAssigned_PodRunInfo
	RunInfo isJobRunAssigned_RunInfo `protobuf_oneof:"run_info"`
}

func (m *JobRunAssigned) Reset()         { *m = JobRunAssigned{} }
func (m *JobRunAssigned) String() string { return proto.CompactTextString(m) }
func (*JobRunAssigned) ProtoMessage()    {}
func (*JobRunAssigned) Descriptor() ([]byte, []int) {
	return fileDescriptor_a7740d41e030ef3b, []int{14}
}
func (m *JobRunAssigned) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobRunAssigned) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JobRunAssigned.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JobRunAssigned) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobRunAssigned.Merge(m, src)
}
func (m *JobRunAssigned) XXX_Size() int {
	return m.Size()
}
func (m *JobRunAssigned) XXX_DiscardUnknown() {
	xxx_messageInfo_JobRunAssigned.DiscardUnknown(m)
}

var xxx_messageInfo_JobRunAssigned proto.InternalMessageInfo

type isJobRunAssigned_RunInfo interface {
	isJobRunAssigned_RunInfo()
	MarshalTo([]byte) (int, error)
	Size() int
}

type JobRunAssigned_PodRunInfo struct {
	PodRunInfo *PodRunInfo `protobuf:"bytes,4,opt,name=podRunInfo,proto3,oneof" json:"podRunInfo,omitempty"`
}

func (*JobRunAssigned_PodRunInfo) isJobRunAssigned_RunInfo() {}

func (m *JobRunAssigned) GetRunInfo() isJobRunAssigned_RunInfo {
	if m != nil {
		return m.RunInfo
	}
	return nil
}

func (m *JobRunAssigned) GetRunId() string {
	if m != nil {
		return m.RunId
	}
	return ""
}

func (m *JobRunAssigned) GetJobId() string {
	if m != nil {
		return m.JobId
	}
	return ""
}

func (m *JobRunAssigned) GetPodRunInfo() *PodRunInfo {
	if x, ok := m.GetRunInfo().(*JobRunAssigned_PodRunInfo); ok {
		return x.PodRunInfo
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*JobRunAssigned) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*JobRunAssigned_PodRunInfo)(nil),
	}
}

// Indicates that a job is now running.
type JobRunRunning struct {
	RunId string `protobuf:"bytes,1,opt,name=run_id,json=runId,proto3" json:"run_id,omitempty"`
	JobId string `protobuf:"bytes,2,opt,name=job_id,json=jobId,proto3" json:"job_id,omitempty"`
	// Runtime information, e.g., which pod the job is running on, its IP address etc.
	//
	// Types that are valid to be assigned to RunInfo:
	//	*JobRunRunning_PodRunInfo
	RunInfo isJobRunRunning_RunInfo `protobuf_oneof:"run_info"`
}

func (m *JobRunRunning) Reset()         { *m = JobRunRunning{} }
func (m *JobRunRunning) String() string { return proto.CompactTextString(m) }
func (*JobRunRunning) ProtoMessage()    {}
func (*JobRunRunning) Descriptor() ([]byte, []int) {
	return fileDescriptor_a7740d41e030ef3b, []int{15}
}
func (m *JobRunRunning) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobRunRunning) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JobRunRunning.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JobRunRunning) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobRunRunning.Merge(m, src)
}
func (m *JobRunRunning) XXX_Size() int {
	return m.Size()
}
func (m *JobRunRunning) XXX_DiscardUnknown() {
	xxx_messageInfo_JobRunRunning.DiscardUnknown(m)
}

var xxx_messageInfo_JobRunRunning proto.InternalMessageInfo

type isJobRunRunning_RunInfo interface {
	isJobRunRunning_RunInfo()
	MarshalTo([]byte) (int, error)
	Size() int
}

type JobRunRunning_PodRunInfo struct {
	PodRunInfo *PodRunInfo `protobuf:"bytes,3,opt,name=podRunInfo,proto3,oneof" json:"podRunInfo,omitempty"`
}

func (*JobRunRunning_PodRunInfo) isJobRunRunning_RunInfo() {}

func (m *JobRunRunning) GetRunInfo() isJobRunRunning_RunInfo {
	if m != nil {
		return m.RunInfo
	}
	return nil
}

func (m *JobRunRunning) GetRunId() string {
	if m != nil {
		return m.RunId
	}
	return ""
}

func (m *JobRunRunning) GetJobId() string {
	if m != nil {
		return m.JobId
	}
	return ""
}

func (m *JobRunRunning) GetPodRunInfo() *PodRunInfo {
	if x, ok := m.GetRunInfo().(*JobRunRunning_PodRunInfo); ok {
		return x.PodRunInfo
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*JobRunRunning) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*JobRunRunning_PodRunInfo)(nil),
	}
}

// Container for runtime information of a job consisting of a podspec.
type PodRunInfo struct {
	ClusterId    string `protobuf:"bytes,1,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty"`
	KubernetesId string `protobuf:"bytes,2,opt,name=kubernetes_id,json=kubernetesId,proto3" json:"kubernetes_id,omitempty"`
	NodeName     string `protobuf:"bytes,3,opt,name=node_name,json=nodeName,proto3" json:"node_name,omitempty"`
	PodNumber    int32  `protobuf:"varint,4,opt,name=pod_number,json=podNumber,proto3" json:"pod_number,omitempty"`
	PodName      string `protobuf:"bytes,5,opt,name=pod_name,json=podName,proto3" json:"pod_name,omitempty"`
	PodNamespace string `protobuf:"bytes,6,opt,name=pod_namespace,json=podNamespace,proto3" json:"pod_namespace,omitempty"`
}

func (m *PodRunInfo) Reset()         { *m = PodRunInfo{} }
func (m *PodRunInfo) String() string { return proto.CompactTextString(m) }
func (*PodRunInfo) ProtoMessage()    {}
func (*PodRunInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_a7740d41e030ef3b, []int{16}
}
func (m *PodRunInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PodRunInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PodRunInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PodRunInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PodRunInfo.Merge(m, src)
}
func (m *PodRunInfo) XXX_Size() int {
	return m.Size()
}
func (m *PodRunInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_PodRunInfo.DiscardUnknown(m)
}

var xxx_messageInfo_PodRunInfo proto.InternalMessageInfo

func (m *PodRunInfo) GetClusterId() string {
	if m != nil {
		return m.ClusterId
	}
	return ""
}

func (m *PodRunInfo) GetKubernetesId() string {
	if m != nil {
		return m.KubernetesId
	}
	return ""
}

func (m *PodRunInfo) GetNodeName() string {
	if m != nil {
		return m.NodeName
	}
	return ""
}

func (m *PodRunInfo) GetPodNumber() int32 {
	if m != nil {
		return m.PodNumber
	}
	return 0
}

func (m *PodRunInfo) GetPodName() string {
	if m != nil {
		return m.PodName
	}
	return ""
}

func (m *PodRunInfo) GetPodNamespace() string {
	if m != nil {
		return m.PodNamespace
	}
	return ""
}

// Indicates an expected job run failure.
type JobRunReturned struct {
	RunId string `protobuf:"bytes,1,opt,name=run_id,json=runId,proto3" json:"run_id,omitempty"`
	JobId string `protobuf:"bytes,2,opt,name=job_id,json=jobId,proto3" json:"job_id,omitempty"`
	// Types that are valid to be assigned to Reason:
	//	*JobRunReturned_LeaseExpired_
	//	*JobRunReturned_JobPreempted_
	Reason isJobRunReturned_Reason `protobuf_oneof:"reason"`
}

func (m *JobRunReturned) Reset()         { *m = JobRunReturned{} }
func (m *JobRunReturned) String() string { return proto.CompactTextString(m) }
func (*JobRunReturned) ProtoMessage()    {}
func (*JobRunReturned) Descriptor() ([]byte, []int) {
	return fileDescriptor_a7740d41e030ef3b, []int{17}
}
func (m *JobRunReturned) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobRunReturned) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JobRunReturned.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JobRunReturned) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobRunReturned.Merge(m, src)
}
func (m *JobRunReturned) XXX_Size() int {
	return m.Size()
}
func (m *JobRunReturned) XXX_DiscardUnknown() {
	xxx_messageInfo_JobRunReturned.DiscardUnknown(m)
}

var xxx_messageInfo_JobRunReturned proto.InternalMessageInfo

type isJobRunReturned_Reason interface {
	isJobRunReturned_Reason()
	MarshalTo([]byte) (int, error)
	Size() int
}

type JobRunReturned_LeaseExpired_ struct {
	LeaseExpired *JobRunReturned_LeaseExpired `protobuf:"bytes,3,opt,name=leaseExpired,proto3,oneof" json:"leaseExpired,omitempty"`
}
type JobRunReturned_JobPreempted_ struct {
	JobPreempted *JobRunReturned_JobPreempted `protobuf:"bytes,4,opt,name=jobPreempted,proto3,oneof" json:"jobPreempted,omitempty"`
}

func (*JobRunReturned_LeaseExpired_) isJobRunReturned_Reason() {}
func (*JobRunReturned_JobPreempted_) isJobRunReturned_Reason() {}

func (m *JobRunReturned) GetReason() isJobRunReturned_Reason {
	if m != nil {
		return m.Reason
	}
	return nil
}

func (m *JobRunReturned) GetRunId() string {
	if m != nil {
		return m.RunId
	}
	return ""
}

func (m *JobRunReturned) GetJobId() string {
	if m != nil {
		return m.JobId
	}
	return ""
}

func (m *JobRunReturned) GetLeaseExpired() *JobRunReturned_LeaseExpired {
	if x, ok := m.GetReason().(*JobRunReturned_LeaseExpired_); ok {
		return x.LeaseExpired
	}
	return nil
}

func (m *JobRunReturned) GetJobPreempted() *JobRunReturned_JobPreempted {
	if x, ok := m.GetReason().(*JobRunReturned_JobPreempted_); ok {
		return x.JobPreempted
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*JobRunReturned) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*JobRunReturned_LeaseExpired_)(nil),
		(*JobRunReturned_JobPreempted_)(nil),
	}
}

type JobRunReturned_LeaseExpired struct {
}

func (m *JobRunReturned_LeaseExpired) Reset()         { *m = JobRunReturned_LeaseExpired{} }
func (m *JobRunReturned_LeaseExpired) String() string { return proto.CompactTextString(m) }
func (*JobRunReturned_LeaseExpired) ProtoMessage()    {}
func (*JobRunReturned_LeaseExpired) Descriptor() ([]byte, []int) {
	return fileDescriptor_a7740d41e030ef3b, []int{17, 0}
}
func (m *JobRunReturned_LeaseExpired) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobRunReturned_LeaseExpired) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JobRunReturned_LeaseExpired.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JobRunReturned_LeaseExpired) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobRunReturned_LeaseExpired.Merge(m, src)
}
func (m *JobRunReturned_LeaseExpired) XXX_Size() int {
	return m.Size()
}
func (m *JobRunReturned_LeaseExpired) XXX_DiscardUnknown() {
	xxx_messageInfo_JobRunReturned_LeaseExpired.DiscardUnknown(m)
}

var xxx_messageInfo_JobRunReturned_LeaseExpired proto.InternalMessageInfo

type JobRunReturned_JobPreempted struct {
}

func (m *JobRunReturned_JobPreempted) Reset()         { *m = JobRunReturned_JobPreempted{} }
func (m *JobRunReturned_JobPreempted) String() string { return proto.CompactTextString(m) }
func (*JobRunReturned_JobPreempted) ProtoMessage()    {}
func (*JobRunReturned_JobPreempted) Descriptor() ([]byte, []int) {
	return fileDescriptor_a7740d41e030ef3b, []int{17, 1}
}
func (m *JobRunReturned_JobPreempted) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobRunReturned_JobPreempted) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JobRunReturned_JobPreempted.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JobRunReturned_JobPreempted) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobRunReturned_JobPreempted.Merge(m, src)
}
func (m *JobRunReturned_JobPreempted) XXX_Size() int {
	return m.Size()
}
func (m *JobRunReturned_JobPreempted) XXX_DiscardUnknown() {
	xxx_messageInfo_JobRunReturned_JobPreempted.DiscardUnknown(m)
}

var xxx_messageInfo_JobRunReturned_JobPreempted proto.InternalMessageInfo

// Indicates that a job is no longer running.
type JobRunSucceeded struct {
	RunId string `protobuf:"bytes,1,opt,name=run_id,json=runId,proto3" json:"run_id,omitempty"`
	JobId string `protobuf:"bytes,2,opt,name=job_id,json=jobId,proto3" json:"job_id,omitempty"`
}

func (m *JobRunSucceeded) Reset()         { *m = JobRunSucceeded{} }
func (m *JobRunSucceeded) String() string { return proto.CompactTextString(m) }
func (*JobRunSucceeded) ProtoMessage()    {}
func (*JobRunSucceeded) Descriptor() ([]byte, []int) {
	return fileDescriptor_a7740d41e030ef3b, []int{18}
}
func (m *JobRunSucceeded) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobRunSucceeded) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JobRunSucceeded.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JobRunSucceeded) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobRunSucceeded.Merge(m, src)
}
func (m *JobRunSucceeded) XXX_Size() int {
	return m.Size()
}
func (m *JobRunSucceeded) XXX_DiscardUnknown() {
	xxx_messageInfo_JobRunSucceeded.DiscardUnknown(m)
}

var xxx_messageInfo_JobRunSucceeded proto.InternalMessageInfo

func (m *JobRunSucceeded) GetRunId() string {
	if m != nil {
		return m.RunId
	}
	return ""
}

func (m *JobRunSucceeded) GetJobId() string {
	if m != nil {
		return m.JobId
	}
	return ""
}

// Indicates that a job is no longer running.
type JobRunFailed struct {
	RunId string `protobuf:"bytes,1,opt,name=run_id,json=runId,proto3" json:"run_id,omitempty"`
	JobId string `protobuf:"bytes,2,opt,name=job_id,json=jobId,proto3" json:"job_id,omitempty"`
	// Types that are valid to be assigned to Reason:
	//	*JobRunFailed_ApplicationFailed_
	//	*JobRunFailed_OomKilled
	Reason isJobRunFailed_Reason `protobuf_oneof:"reason"`
}

func (m *JobRunFailed) Reset()         { *m = JobRunFailed{} }
func (m *JobRunFailed) String() string { return proto.CompactTextString(m) }
func (*JobRunFailed) ProtoMessage()    {}
func (*JobRunFailed) Descriptor() ([]byte, []int) {
	return fileDescriptor_a7740d41e030ef3b, []int{19}
}
func (m *JobRunFailed) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobRunFailed) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JobRunFailed.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JobRunFailed) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobRunFailed.Merge(m, src)
}
func (m *JobRunFailed) XXX_Size() int {
	return m.Size()
}
func (m *JobRunFailed) XXX_DiscardUnknown() {
	xxx_messageInfo_JobRunFailed.DiscardUnknown(m)
}

var xxx_messageInfo_JobRunFailed proto.InternalMessageInfo

type isJobRunFailed_Reason interface {
	isJobRunFailed_Reason()
	MarshalTo([]byte) (int, error)
	Size() int
}

type JobRunFailed_ApplicationFailed_ struct {
	ApplicationFailed *JobRunFailed_ApplicationFailed `protobuf:"bytes,3,opt,name=applicationFailed,proto3,oneof" json:"applicationFailed,omitempty"`
}
type JobRunFailed_OomKilled struct {
	OomKilled *JobRunFailed_OOMKilled `protobuf:"bytes,4,opt,name=oomKilled,proto3,oneof" json:"oomKilled,omitempty"`
}

func (*JobRunFailed_ApplicationFailed_) isJobRunFailed_Reason() {}
func (*JobRunFailed_OomKilled) isJobRunFailed_Reason()          {}

func (m *JobRunFailed) GetReason() isJobRunFailed_Reason {
	if m != nil {
		return m.Reason
	}
	return nil
}

func (m *JobRunFailed) GetRunId() string {
	if m != nil {
		return m.RunId
	}
	return ""
}

func (m *JobRunFailed) GetJobId() string {
	if m != nil {
		return m.JobId
	}
	return ""
}

func (m *JobRunFailed) GetApplicationFailed() *JobRunFailed_ApplicationFailed {
	if x, ok := m.GetReason().(*JobRunFailed_ApplicationFailed_); ok {
		return x.ApplicationFailed
	}
	return nil
}

func (m *JobRunFailed) GetOomKilled() *JobRunFailed_OOMKilled {
	if x, ok := m.GetReason().(*JobRunFailed_OomKilled); ok {
		return x.OomKilled
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*JobRunFailed) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*JobRunFailed_ApplicationFailed_)(nil),
		(*JobRunFailed_OomKilled)(nil),
	}
}

type JobRunFailed_ApplicationFailed struct {
	RunId string `protobuf:"bytes,1,opt,name=run_id,json=runId,proto3" json:"run_id,omitempty"`
	JobId string `protobuf:"bytes,2,opt,name=job_id,json=jobId,proto3" json:"job_id,omitempty"`
	// Application exit code.
	Code int32 `protobuf:"varint,3,opt,name=code,proto3" json:"code,omitempty"`
	// Error message returned by the application.
	Error string `protobuf:"bytes,4,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *JobRunFailed_ApplicationFailed) Reset()         { *m = JobRunFailed_ApplicationFailed{} }
func (m *JobRunFailed_ApplicationFailed) String() string { return proto.CompactTextString(m) }
func (*JobRunFailed_ApplicationFailed) ProtoMessage()    {}
func (*JobRunFailed_ApplicationFailed) Descriptor() ([]byte, []int) {
	return fileDescriptor_a7740d41e030ef3b, []int{19, 0}
}
func (m *JobRunFailed_ApplicationFailed) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobRunFailed_ApplicationFailed) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JobRunFailed_ApplicationFailed.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JobRunFailed_ApplicationFailed) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobRunFailed_ApplicationFailed.Merge(m, src)
}
func (m *JobRunFailed_ApplicationFailed) XXX_Size() int {
	return m.Size()
}
func (m *JobRunFailed_ApplicationFailed) XXX_DiscardUnknown() {
	xxx_messageInfo_JobRunFailed_ApplicationFailed.DiscardUnknown(m)
}

var xxx_messageInfo_JobRunFailed_ApplicationFailed proto.InternalMessageInfo

func (m *JobRunFailed_ApplicationFailed) GetRunId() string {
	if m != nil {
		return m.RunId
	}
	return ""
}

func (m *JobRunFailed_ApplicationFailed) GetJobId() string {
	if m != nil {
		return m.JobId
	}
	return ""
}

func (m *JobRunFailed_ApplicationFailed) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *JobRunFailed_ApplicationFailed) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type JobRunFailed_OOMKilled struct {
}

func (m *JobRunFailed_OOMKilled) Reset()         { *m = JobRunFailed_OOMKilled{} }
func (m *JobRunFailed_OOMKilled) String() string { return proto.CompactTextString(m) }
func (*JobRunFailed_OOMKilled) ProtoMessage()    {}
func (*JobRunFailed_OOMKilled) Descriptor() ([]byte, []int) {
	return fileDescriptor_a7740d41e030ef3b, []int{19, 1}
}
func (m *JobRunFailed_OOMKilled) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobRunFailed_OOMKilled) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JobRunFailed_OOMKilled.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JobRunFailed_OOMKilled) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobRunFailed_OOMKilled.Merge(m, src)
}
func (m *JobRunFailed_OOMKilled) XXX_Size() int {
	return m.Size()
}
func (m *JobRunFailed_OOMKilled) XXX_DiscardUnknown() {
	xxx_messageInfo_JobRunFailed_OOMKilled.DiscardUnknown(m)
}

var xxx_messageInfo_JobRunFailed_OOMKilled proto.InternalMessageInfo

func init() {
	proto.RegisterType((*EventSequence)(nil), "events.EventSequence")
	proto.RegisterType((*EventSequence_Event)(nil), "events.EventSequence.Event")
	proto.RegisterType((*SubmitJob)(nil), "events.SubmitJob")
	proto.RegisterType((*KubernetesMainObject)(nil), "events.KubernetesMainObject")
	proto.RegisterType((*KubernetesObject)(nil), "events.KubernetesObject")
	proto.RegisterType((*ObjectMeta)(nil), "events.ObjectMeta")
	proto.RegisterMapType((map[string]string)(nil), "events.ObjectMeta.AnnotationsEntry")
	proto.RegisterMapType((map[string]string)(nil), "events.ObjectMeta.LabelsEntry")
	proto.RegisterType((*PodSpecWithAvoidList)(nil), "events.PodSpecWithAvoidList")
	proto.RegisterType((*ReprioritiseJob)(nil), "events.ReprioritiseJob")
	proto.RegisterType((*ReprioritiseJobSet)(nil), "events.ReprioritiseJobSet")
	proto.RegisterType((*CancelJob)(nil), "events.CancelJob")
	proto.RegisterType((*CancelJobSet)(nil), "events.CancelJobSet")
	proto.RegisterType((*JobSucceeded)(nil), "events.JobSucceeded")
	proto.RegisterType((*JobFailed)(nil), "events.JobFailed")
	proto.RegisterType((*JobFailed_MaxRunsExceeded)(nil), "events.JobFailed.MaxRunsExceeded")
	proto.RegisterType((*JobRejected)(nil), "events.JobRejected")
	proto.RegisterType((*JobRejected_JobUnschedulable)(nil), "events.JobRejected.JobUnschedulable")
	proto.RegisterType((*JobRunLeased)(nil), "events.JobRunLeased")
	proto.RegisterType((*JobRunAssigned)(nil), "events.JobRunAssigned")
	proto.RegisterType((*JobRunRunning)(nil), "events.JobRunRunning")
	proto.RegisterType((*PodRunInfo)(nil), "events.PodRunInfo")
	proto.RegisterType((*JobRunReturned)(nil), "events.JobRunReturned")
	proto.RegisterType((*JobRunReturned_LeaseExpired)(nil), "events.JobRunReturned.LeaseExpired")
	proto.RegisterType((*JobRunReturned_JobPreempted)(nil), "events.JobRunReturned.JobPreempted")
	proto.RegisterType((*JobRunSucceeded)(nil), "events.JobRunSucceeded")
	proto.RegisterType((*JobRunFailed)(nil), "events.JobRunFailed")
	proto.RegisterType((*JobRunFailed_ApplicationFailed)(nil), "events.JobRunFailed.ApplicationFailed")
	proto.RegisterType((*JobRunFailed_OOMKilled)(nil), "events.JobRunFailed.OOMKilled")
}

func init() { proto.RegisterFile("internal/events/events.proto", fileDescriptor_a7740d41e030ef3b) }

var fileDescriptor_a7740d41e030ef3b = []byte{
	// 1493 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x57, 0x4b, 0x73, 0x1b, 0xc5,
	0x13, 0x97, 0x64, 0xeb, 0xd5, 0x92, 0x5f, 0xf3, 0x77, 0x92, 0xfd, 0x2b, 0x89, 0x62, 0xd6, 0x84,
	0x0a, 0x54, 0x21, 0x63, 0x87, 0x0a, 0x49, 0x20, 0x01, 0x3b, 0x38, 0x25, 0x39, 0x76, 0x92, 0x5a,
	0x17, 0x70, 0xa0, 0x28, 0xd7, 0x3e, 0xda, 0xf2, 0xca, 0xd2, 0xcc, 0x66, 0x1f, 0xc6, 0x39, 0xc1,
	0x27, 0xa0, 0x38, 0xf1, 0x09, 0xb8, 0xf0, 0x29, 0xb8, 0x72, 0xa0, 0x8a, 0x1c, 0x73, 0xa4, 0x92,
	0x33, 0x5f, 0x81, 0xa2, 0xe6, 0xb1, 0x2f, 0x49, 0xa6, 0x30, 0x9c, 0xa4, 0xee, 0xfe, 0xfd, 0x7a,
	0x7a, 0x7a, 0x66, 0xba, 0x7b, 0xe1, 0x8a, 0x4b, 0x43, 0xf4, 0xa9, 0x39, 0x5c, 0xc3, 0x13, 0xa4,
	0x61, 0xa0, 0x7e, 0x3a, 0x9e, 0xcf, 0x42, 0x46, 0x2a, 0x52, 0x6a, 0xe9, 0xc7, 0xb7, 0x83, 0x8e,
	0xcb, 0xd6, 0x4c, 0xcf, 0x5d, 0xb3, 0x99, 0x8f, 0x6b, 0x27, 0xeb, 0x6b, 0x7d, 0xa4, 0xe8, 0x9b,
	0x21, 0x3a, 0x12, 0xdb, 0x7a, 0x37, 0x83, 0xa1, 0x18, 0x7e, 0xcd, 0xfc, 0x63, 0x97, 0xf6, 0xd7,
	0x4e, 0xd6, 0x2d, 0x0c, 0xcd, 0x09, 0xb8, 0xfe, 0x73, 0x0d, 0xe6, 0xb6, 0xb9, 0xf7, 0x7d, 0x7c,
	0x16, 0x21, 0xb5, 0x91, 0x2c, 0x43, 0xf9, 0x59, 0x84, 0x11, 0x6a, 0xc5, 0x95, 0xe2, 0x8d, 0xba,
	0x21, 0x05, 0xb2, 0x02, 0xcd, 0x01, 0xb3, 0x0e, 0x02, 0x0c, 0x0f, 0xa8, 0x39, 0x42, 0xad, 0x24,
	0x8c, 0x30, 0x60, 0xd6, 0x3e, 0x86, 0x8f, 0xcd, 0x51, 0x0e, 0x71, 0x64, 0x06, 0x47, 0xda, 0xcc,
	0x4a, 0xf1, 0x46, 0x33, 0x46, 0x74, 0xcd, 0xe0, 0x88, 0x5c, 0x82, 0x6a, 0x14, 0xa0, 0x7f, 0xe0,
	0x3a, 0xda, 0xac, 0xa0, 0x57, 0xb8, 0xd8, 0x73, 0xc8, 0x45, 0xa8, 0xf4, 0x7d, 0x16, 0x79, 0x81,
	0x56, 0x5e, 0x99, 0xe1, 0x7a, 0x29, 0x91, 0x9b, 0xa0, 0x76, 0xae, 0x55, 0x56, 0x66, 0x6e, 0x34,
	0x36, 0x2e, 0x77, 0x54, 0x5a, 0x72, 0x11, 0x4b, 0xc9, 0x88, 0x93, 0xf4, 0x47, 0x05, 0xca, 0x42,
	0x43, 0xd6, 0xa1, 0x1e, 0x44, 0xd6, 0xc8, 0x0d, 0x77, 0x98, 0x25, 0x76, 0xd3, 0xd8, 0x58, 0x8a,
	0x3d, 0xec, 0xc7, 0x86, 0x6e, 0xc1, 0x48, 0x51, 0xe4, 0x01, 0x2c, 0xf8, 0xe8, 0xf9, 0x2e, 0xf3,
	0xdd, 0xd0, 0x0d, 0x90, 0x13, 0x4b, 0x82, 0x78, 0x29, 0x26, 0x1a, 0x79, 0x73, 0xb7, 0x60, 0x8c,
	0x33, 0xc8, 0x2e, 0x90, 0x31, 0xd5, 0x3e, 0x86, 0x22, 0x1f, 0x8d, 0x8d, 0xd6, 0x19, 0x7e, 0x78,
	0x8e, 0x0a, 0xc6, 0x14, 0x1e, 0xdf, 0x85, 0x6d, 0x52, 0x1b, 0x87, 0x3c, 0x98, 0xd9, 0xfc, 0x2e,
	0x1e, 0xc4, 0x06, 0xbe, 0x8b, 0x04, 0x45, 0xee, 0x42, 0x33, 0x11, 0xf8, 0xd2, 0x65, 0xc1, 0x5a,
	0x9e, 0x60, 0xc9, 0x45, 0x73, 0x58, 0xce, 0xe5, 0x47, 0x16, 0xd9, 0x36, 0xa2, 0x83, 0x8e, 0x56,
	0xc9, 0x73, 0x77, 0x32, 0x36, 0xce, 0xcd, 0x62, 0x79, 0xa8, 0x03, 0x66, 0x3d, 0x34, 0xdd, 0x21,
	0x3a, 0x5a, 0x35, 0x1f, 0xea, 0x4e, 0x6c, 0xe0, 0xa1, 0x26, 0x28, 0xf2, 0x01, 0x34, 0x06, 0xcc,
	0x32, 0x70, 0x80, 0x76, 0x88, 0x8e, 0x56, 0x13, 0xa4, 0xff, 0x65, 0x48, 0xb1, 0xa9, 0x5b, 0x30,
	0xb2, 0x48, 0x15, 0xa7, 0x11, 0xd1, 0x5d, 0x34, 0x03, 0x74, 0xb4, 0xfa, 0x44, 0x9c, 0x89, 0x4d,
	0xc5, 0x99, 0xc8, 0xe4, 0x13, 0x98, 0x97, 0xf2, 0x66, 0x10, 0xb8, 0x7d, 0x8a, 0x8e, 0x06, 0x82,
	0x7d, 0x31, 0xcf, 0x8e, 0xad, 0xdd, 0x82, 0x31, 0x86, 0x27, 0xf7, 0x60, 0x4e, 0x6a, 0x8c, 0x88,
	0x52, 0x97, 0xf6, 0xb5, 0x86, 0x70, 0x70, 0x21, 0xef, 0x40, 0x19, 0xbb, 0x05, 0x23, 0x8f, 0x4e,
	0x03, 0x30, 0x30, 0x8c, 0x7c, 0x1e, 0x40, 0x73, 0x5a, 0x00, 0xb1, 0x35, 0x0d, 0x20, 0xd6, 0xf0,
	0x8b, 0x2a, 0x35, 0xe9, 0x49, 0xcd, 0xe5, 0x2f, 0xea, 0x4e, 0xde, 0xcc, 0x2f, 0xea, 0x18, 0x23,
	0xcd, 0xa1, 0x3a, 0xb2, 0xf9, 0x69, 0x39, 0x4c, 0x4e, 0x2d, 0x87, 0xdd, 0xaa, 0x42, 0x59, 0xc0,
	0xf4, 0x9f, 0x4a, 0x50, 0x4f, 0x5e, 0x13, 0xb9, 0x00, 0x15, 0x5e, 0x05, 0x5c, 0x27, 0x2e, 0x1f,
	0x03, 0x66, 0xf5, 0x1c, 0xf2, 0x36, 0x2c, 0x3a, 0xe8, 0x44, 0xde, 0xd0, 0xb5, 0xcd, 0xd0, 0x65,
	0x94, 0x03, 0x64, 0x09, 0x59, 0xc8, 0xe9, 0x7b, 0x0e, 0x69, 0x41, 0x4d, 0xbd, 0x81, 0xe7, 0xe2,
	0xcd, 0x14, 0x8d, 0x44, 0x26, 0x1a, 0x54, 0x0f, 0x7d, 0xb3, 0xef, 0x0e, 0x51, 0xbc, 0x84, 0x9a,
	0x11, 0x8b, 0x64, 0x03, 0x80, 0x59, 0xfc, 0x6a, 0xec, 0x61, 0x68, 0xaa, 0x0b, 0x4f, 0xe2, 0x8d,
	0x3c, 0x49, 0x2c, 0x46, 0x06, 0x45, 0x3e, 0x02, 0x18, 0x99, 0x2e, 0x95, 0x56, 0x75, 0xd1, 0xaf,
	0xc4, 0x9c, 0x47, 0x91, 0x85, 0x3e, 0xc5, 0x10, 0x83, 0xbd, 0x04, 0x63, 0x64, 0xf0, 0x64, 0x03,
	0xaa, 0xd2, 0x57, 0xa0, 0x55, 0x45, 0x75, 0xd2, 0x26, 0xa9, 0x8a, 0x16, 0x03, 0xf5, 0x2f, 0x61,
	0x79, 0x9a, 0x5f, 0x72, 0x07, 0x6a, 0x1e, 0x73, 0x0e, 0x02, 0x0f, 0x6d, 0x55, 0xa8, 0x92, 0x38,
	0x9e, 0x32, 0x67, 0xdf, 0x43, 0xfb, 0x0b, 0x37, 0x3c, 0xda, 0x3c, 0x61, 0xae, 0xb3, 0xeb, 0x06,
	0xfc, 0xd1, 0x56, 0x3d, 0xa9, 0xdf, 0xaa, 0x41, 0x45, 0x7a, 0xd7, 0x7f, 0x2b, 0xc1, 0xe2, 0xf8,
	0xd2, 0x63, 0x79, 0x29, 0xfe, 0xa3, 0xbc, 0x64, 0xa3, 0x29, 0x9d, 0x2b, 0x1a, 0xf2, 0x10, 0xaa,
	0x2e, 0xed, 0xfb, 0x18, 0x04, 0xaa, 0xde, 0xbd, 0xd3, 0x91, 0xfd, 0xa8, 0x63, 0x7a, 0x6e, 0x27,
	0xed, 0x47, 0x1d, 0xd5, 0x8f, 0x3a, 0x3d, 0x89, 0xe6, 0x64, 0xee, 0x47, 0x91, 0xc9, 0x87, 0x50,
	0x0d, 0xd0, 0x3f, 0x71, 0x6d, 0x54, 0x25, 0xef, 0x5a, 0xd6, 0x0f, 0xef, 0x7d, 0x9d, 0x93, 0xf5,
	0xce, 0xbe, 0x84, 0xc4, 0x64, 0xc5, 0x20, 0xf7, 0xa0, 0x6e, 0x33, 0x7a, 0xe8, 0xf6, 0xf7, 0x4c,
	0x4f, 0x5d, 0x85, 0xab, 0xd3, 0xe8, 0x0f, 0x62, 0x90, 0xa8, 0x9e, 0xb1, 0x90, 0xc9, 0xe8, 0x8f,
	0x25, 0x80, 0x34, 0x47, 0xe4, 0x0a, 0xd4, 0x79, 0xef, 0x0b, 0x3c, 0xd3, 0x8e, 0xbb, 0x63, 0xaa,
	0x20, 0xdb, 0xd0, 0x30, 0x29, 0x65, 0xa1, 0xb8, 0xc7, 0x81, 0x56, 0x12, 0x77, 0x62, 0x75, 0x32,
	0xd5, 0x9d, 0xcd, 0x14, 0xb5, 0x4d, 0x43, 0xff, 0xb9, 0x91, 0xe5, 0x91, 0x5b, 0x50, 0x19, 0x9a,
	0x16, 0x0e, 0x79, 0x02, 0xb9, 0x87, 0xf6, 0x14, 0x0f, 0xbb, 0x02, 0x20, 0xc9, 0x0a, 0xdd, 0xba,
	0x0f, 0x8b, 0xe3, 0x8e, 0xc9, 0x22, 0xcc, 0x1c, 0xe3, 0x73, 0x15, 0x2a, 0xff, 0xcb, 0x9b, 0xfb,
	0x89, 0x39, 0x8c, 0xe2, 0xfe, 0x2d, 0x85, 0xbb, 0xa5, 0xdb, 0xc5, 0xd6, 0x1d, 0x68, 0x64, 0xdc,
	0x9e, 0x87, 0xaa, 0x47, 0xb0, 0x3c, 0xed, 0x5e, 0x90, 0x5b, 0x13, 0xb7, 0xfa, 0xf2, 0xb4, 0x63,
	0x50, 0xdc, 0xf4, 0x12, 0x5d, 0x87, 0x79, 0xca, 0x1c, 0x3c, 0x30, 0xb9, 0xa7, 0xa1, 0x1b, 0x84,
	0x22, 0x99, 0x75, 0x63, 0x8e, 0x6b, 0x37, 0x63, 0xa5, 0xfe, 0x29, 0x2c, 0x8c, 0x35, 0xd1, 0xb3,
	0xaa, 0x4f, 0xb6, 0xa4, 0x94, 0xf2, 0x25, 0x45, 0x7f, 0x0f, 0xc8, 0x64, 0x2b, 0xce, 0x31, 0x8a,
	0x63, 0x0c, 0x1d, 0xea, 0x49, 0x07, 0x3d, 0x63, 0x45, 0x7d, 0x1e, 0x9a, 0xd9, 0x2e, 0xab, 0x5f,
	0x87, 0x66, 0xb6, 0x73, 0x9e, 0x45, 0xfb, 0xae, 0x08, 0xf5, 0xa4, 0x51, 0x9e, 0xb5, 0x9b, 0x3d,
	0x58, 0x18, 0x99, 0xa7, 0x46, 0x44, 0x83, 0xed, 0x53, 0x55, 0xfa, 0xe5, 0x2b, 0x7d, 0x63, 0xa2,
	0xd7, 0x76, 0xf6, 0xf2, 0x40, 0xde, 0x04, 0xc6, 0xb8, 0xad, 0x25, 0x58, 0x18, 0x43, 0xf1, 0x17,
	0xe0, 0xa3, 0x19, 0x30, 0xaa, 0xff, 0x50, 0x84, 0x46, 0xa6, 0x09, 0x9f, 0x15, 0x92, 0x01, 0x8b,
	0x03, 0x66, 0x7d, 0x46, 0x03, 0xfb, 0x08, 0x9d, 0x68, 0x68, 0x5a, 0x43, 0x54, 0x31, 0xbd, 0x39,
	0xa5, 0x95, 0xf3, 0xff, 0x39, 0x6c, 0xb7, 0x60, 0x4c, 0xf0, 0x5b, 0x04, 0x16, 0xc7, 0x71, 0x99,
	0xc0, 0xbe, 0x12, 0x09, 0x4d, 0x5b, 0xfa, 0x05, 0xa8, 0xf8, 0x11, 0xcd, 0x04, 0xe6, 0x47, 0xbc,
	0x99, 0xa4, 0xf1, 0x96, 0xb2, 0xf1, 0x5e, 0x83, 0x06, 0x9e, 0xa2, 0x1d, 0x85, 0x4c, 0x4c, 0xa3,
	0x33, 0x72, 0x98, 0x8d, 0x55, 0x3d, 0x47, 0xff, 0xb6, 0x08, 0xf3, 0xf9, 0x21, 0xe0, 0x9c, 0x2b,
	0xbc, 0x0f, 0xe0, 0x31, 0xc7, 0x88, 0x68, 0x8f, 0x1e, 0x32, 0x55, 0xc3, 0x48, 0xa6, 0x8a, 0x2a,
	0x4b, 0xb7, 0x60, 0x64, 0x70, 0x5b, 0x00, 0x35, 0xb1, 0x06, 0x3d, 0x64, 0xfa, 0x37, 0x30, 0x97,
	0x9b, 0x22, 0xfe, 0x53, 0x00, 0x33, 0xff, 0x22, 0x80, 0x5f, 0x8b, 0x00, 0x29, 0x90, 0x5c, 0x05,
	0xb0, 0x87, 0x51, 0x10, 0xca, 0x01, 0x5e, 0x95, 0x3f, 0xa5, 0xe9, 0x39, 0x64, 0x15, 0xe6, 0x8e,
	0x93, 0xe6, 0x93, 0x46, 0xd3, 0x4c, 0x95, 0x3d, 0x87, 0x5c, 0x86, 0xba, 0x78, 0xd9, 0xe2, 0x13,
	0x42, 0x66, 0xbd, 0xc6, 0x15, 0xe2, 0x03, 0xe2, 0xaa, 0x88, 0xf8, 0x80, 0x46, 0x23, 0x0b, 0x7d,
	0x91, 0xb2, 0xb2, 0x51, 0xf7, 0x98, 0xf3, 0x58, 0x28, 0xc8, 0xff, 0x65, 0x35, 0x11, 0xd4, 0xb2,
	0xa0, 0xf2, 0x82, 0x21, 0x98, 0xab, 0x30, 0x17, 0x9b, 0x64, 0x71, 0xae, 0xc8, 0xb5, 0x95, 0x5d,
	0xe8, 0xf4, 0x3f, 0x93, 0x23, 0x4d, 0x86, 0xa8, 0xf3, 0x65, 0xb4, 0x07, 0xcd, 0x21, 0xbf, 0x6c,
	0xdb, 0xa7, 0x9e, 0xeb, 0xa3, 0xa3, 0x72, 0xba, 0x3a, 0x7d, 0x64, 0xeb, 0xec, 0x66, 0xa0, 0x7c,
	0x78, 0xca, 0x52, 0xb9, 0xab, 0x01, 0xb3, 0x9e, 0xfa, 0x88, 0x23, 0x8f, 0x8f, 0xbd, 0xb3, 0x7f,
	0xeb, 0x6a, 0x27, 0x03, 0x55, 0x73, 0x58, 0x22, 0xb7, 0xe6, 0xa1, 0x99, 0x5d, 0x8a, 0xcb, 0x59,
	0x7c, 0xe6, 0xc9, 0x7c, 0x0c, 0x0b, 0x63, 0x33, 0xe1, 0xf9, 0x12, 0xa0, 0xbf, 0x2c, 0xc5, 0x8f,
	0x2e, 0x2d, 0x50, 0xe7, 0xc8, 0xdf, 0xe7, 0xb0, 0x64, 0x7a, 0xc9, 0xa4, 0xa7, 0x46, 0x4e, 0x99,
	0xc4, 0xb7, 0xa6, 0x8d, 0x9c, 0x9d, 0xcd, 0x71, 0x74, 0xb7, 0x60, 0x4c, 0xba, 0x20, 0xf7, 0xa1,
	0xce, 0xd8, 0xe8, 0x91, 0x3b, 0x1c, 0x26, 0x99, 0x6c, 0x4f, 0xf5, 0xf7, 0xe4, 0xc9, 0x9e, 0x44,
	0xf1, 0x7e, 0x9f, 0x50, 0x5a, 0xc7, 0xb0, 0x34, 0xb1, 0xd2, 0x39, 0xb7, 0x46, 0x60, 0xd6, 0x66,
	0x8e, 0xbc, 0xd2, 0x65, 0x43, 0xfc, 0xe7, 0xfd, 0x12, 0x7d, 0x9f, 0xf9, 0xea, 0x5b, 0x57, 0x0a,
	0xad, 0x06, 0xd4, 0x93, 0x30, 0xd2, 0xb3, 0xd9, 0xd2, 0x7e, 0x79, 0xd5, 0x2e, 0xbe, 0x78, 0xd5,
	0x2e, 0xfe, 0xfe, 0xaa, 0x5d, 0xfc, 0xfe, 0x75, 0xbb, 0xf0, 0xe2, 0x75, 0xbb, 0xf0, 0xf2, 0x75,
	0xbb, 0x60, 0x55, 0xc4, 0x77, 0xfa, 0xcd, 0xbf, 0x02, 0x00, 0x00, 0xff, 0xff, 0xc0, 0x59, 0x86,
	0x5c, 0x22, 0x10, 0x00, 0x00,
}

func (m *EventSequence) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSequence) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSequence) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Events) > 0 {
		for iNdEx := len(m.Events) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Events[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Groups) > 0 {
		for iNdEx := len(m.Groups) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Groups[iNdEx])
			copy(dAtA[i:], m.Groups[iNdEx])
			i = encodeVarintEvents(dAtA, i, uint64(len(m.Groups[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.UserId) > 0 {
		i -= len(m.UserId)
		copy(dAtA[i:], m.UserId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.UserId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.JobSetHash) > 0 {
		i -= len(m.JobSetHash)
		copy(dAtA[i:], m.JobSetHash)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.JobSetHash)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.JobSetName) > 0 {
		i -= len(m.JobSetName)
		copy(dAtA[i:], m.JobSetName)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.JobSetName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Queue) > 0 {
		i -= len(m.Queue)
		copy(dAtA[i:], m.Queue)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Queue)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventSequence_Event) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSequence_Event) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSequence_Event) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Event != nil {
		{
			size := m.Event.Size()
			i -= size
			if _, err := m.Event.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *EventSequence_Event_SubmitJob) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSequence_Event_SubmitJob) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SubmitJob != nil {
		{
			size, err := m.SubmitJob.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *EventSequence_Event_ReprioritiseJob) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSequence_Event_ReprioritiseJob) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ReprioritiseJob != nil {
		{
			size, err := m.ReprioritiseJob.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *EventSequence_Event_ReprioritiseJobSet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSequence_Event_ReprioritiseJobSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ReprioritiseJobSet != nil {
		{
			size, err := m.ReprioritiseJobSet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *EventSequence_Event_CancelJob) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSequence_Event_CancelJob) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CancelJob != nil {
		{
			size, err := m.CancelJob.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *EventSequence_Event_CancelJobSet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSequence_Event_CancelJobSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CancelJobSet != nil {
		{
			size, err := m.CancelJobSet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *EventSequence_Event_JobSucceeded) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSequence_Event_JobSucceeded) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.JobSucceeded != nil {
		{
			size, err := m.JobSucceeded.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *EventSequence_Event_JobFailed) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSequence_Event_JobFailed) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.JobFailed != nil {
		{
			size, err := m.JobFailed.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *EventSequence_Event_JobRejected) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSequence_Event_JobRejected) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.JobRejected != nil {
		{
			size, err := m.JobRejected.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *EventSequence_Event_JobRunLeased) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSequence_Event_JobRunLeased) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.JobRunLeased != nil {
		{
			size, err := m.JobRunLeased.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *EventSequence_Event_JobRunAssigned) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSequence_Event_JobRunAssigned) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.JobRunAssigned != nil {
		{
			size, err := m.JobRunAssigned.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *EventSequence_Event_JobRunRunning) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSequence_Event_JobRunRunning) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.JobRunRunning != nil {
		{
			size, err := m.JobRunRunning.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *EventSequence_Event_JobRunReturned) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSequence_Event_JobRunReturned) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.JobRunReturned != nil {
		{
			size, err := m.JobRunReturned.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func (m *EventSequence_Event_JobRunSucceeded) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSequence_Event_JobRunSucceeded) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.JobRunSucceeded != nil {
		{
			size, err := m.JobRunSucceeded.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	return len(dAtA) - i, nil
}
func (m *EventSequence_Event_JobRunFailed) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSequence_Event_JobRunFailed) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.JobRunFailed != nil {
		{
			size, err := m.JobRunFailed.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	return len(dAtA) - i, nil
}
func (m *SubmitJob) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubmitJob) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubmitJob) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Objects) > 0 {
		for iNdEx := len(m.Objects) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Objects[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.MainObject != nil {
		{
			size, err := m.MainObject.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.ObjectMeta != nil {
		{
			size, err := m.ObjectMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Fragile {
		i--
		if m.Fragile {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Priority != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Priority))))
		i--
		dAtA[i] = 0x19
	}
	if len(m.DeduplicationId) > 0 {
		i -= len(m.DeduplicationId)
		copy(dAtA[i:], m.DeduplicationId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.DeduplicationId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.JobId) > 0 {
		i -= len(m.JobId)
		copy(dAtA[i:], m.JobId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.JobId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *KubernetesMainObject) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KubernetesMainObject) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KubernetesMainObject) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Object != nil {
		{
			size := m.Object.Size()
			i -= size
			if _, err := m.Object.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *KubernetesMainObject_PodSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KubernetesMainObject_PodSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PodSpec != nil {
		{
			size, err := m.PodSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *KubernetesObject) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KubernetesObject) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KubernetesObject) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Object != nil {
		{
			size := m.Object.Size()
			i -= size
			if _, err := m.Object.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.ObjectMeta != nil {
		{
			size, err := m.ObjectMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *KubernetesObject_PodSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KubernetesObject_PodSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PodSpec != nil {
		{
			size, err := m.PodSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *KubernetesObject_Ingress) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KubernetesObject_Ingress) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Ingress != nil {
		{
			size, err := m.Ingress.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *KubernetesObject_Service) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KubernetesObject_Service) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Service != nil {
		{
			size, err := m.Service.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *KubernetesObject_ConfigMap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KubernetesObject_ConfigMap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ConfigMap != nil {
		{
			size, err := m.ConfigMap.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *ObjectMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ObjectMeta) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ObjectMeta) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Labels) > 0 {
		for k := range m.Labels {
			v := m.Labels[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintEvents(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintEvents(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintEvents(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Annotations) > 0 {
		for k := range m.Annotations {
			v := m.Annotations[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintEvents(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintEvents(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintEvents(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PodSpecWithAvoidList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PodSpecWithAvoidList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PodSpecWithAvoidList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NodeAvoidlist) > 0 {
		for iNdEx := len(m.NodeAvoidlist) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.NodeAvoidlist[iNdEx])
			copy(dAtA[i:], m.NodeAvoidlist[iNdEx])
			i = encodeVarintEvents(dAtA, i, uint64(len(m.NodeAvoidlist[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.PodSpec != nil {
		{
			size, err := m.PodSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReprioritiseJob) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReprioritiseJob) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReprioritiseJob) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Priority != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Priority))))
		i--
		dAtA[i] = 0x11
	}
	if len(m.JobId) > 0 {
		i -= len(m.JobId)
		copy(dAtA[i:], m.JobId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.JobId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReprioritiseJobSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReprioritiseJobSet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReprioritiseJobSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Priority != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Priority))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *CancelJob) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CancelJob) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CancelJob) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.JobId) > 0 {
		i -= len(m.JobId)
		copy(dAtA[i:], m.JobId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.JobId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CancelJobSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CancelJobSet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CancelJobSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *JobSucceeded) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobSucceeded) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobSucceeded) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.JobId) > 0 {
		i -= len(m.JobId)
		copy(dAtA[i:], m.JobId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.JobId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *JobFailed) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobFailed) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobFailed) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Reason != nil {
		{
			size := m.Reason.Size()
			i -= size
			if _, err := m.Reason.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.JobId) > 0 {
		i -= len(m.JobId)
		copy(dAtA[i:], m.JobId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.JobId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *JobFailed_MaxRunsExceeded_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobFailed_MaxRunsExceeded_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MaxRunsExceeded != nil {
		{
			size, err := m.MaxRunsExceeded.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *JobFailed_MaxRunsExceeded) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobFailed_MaxRunsExceeded) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobFailed_MaxRunsExceeded) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *JobRejected) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobRejected) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobRejected) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Reason != nil {
		{
			size := m.Reason.Size()
			i -= size
			if _, err := m.Reason.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.JobId) > 0 {
		i -= len(m.JobId)
		copy(dAtA[i:], m.JobId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.JobId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *JobRejected_JobUnschedulable_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobRejected_JobUnschedulable_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.JobUnschedulable != nil {
		{
			size, err := m.JobUnschedulable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *JobRejected_JobUnschedulable) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobRejected_JobUnschedulable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobRejected_JobUnschedulable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *JobRunLeased) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobRunLeased) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobRunLeased) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ExecutorId) > 0 {
		i -= len(m.ExecutorId)
		copy(dAtA[i:], m.ExecutorId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.ExecutorId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.JobId) > 0 {
		i -= len(m.JobId)
		copy(dAtA[i:], m.JobId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.JobId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RunId) > 0 {
		i -= len(m.RunId)
		copy(dAtA[i:], m.RunId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.RunId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *JobRunAssigned) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobRunAssigned) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobRunAssigned) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RunInfo != nil {
		{
			size := m.RunInfo.Size()
			i -= size
			if _, err := m.RunInfo.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.JobId) > 0 {
		i -= len(m.JobId)
		copy(dAtA[i:], m.JobId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.JobId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RunId) > 0 {
		i -= len(m.RunId)
		copy(dAtA[i:], m.RunId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.RunId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *JobRunAssigned_PodRunInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobRunAssigned_PodRunInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PodRunInfo != nil {
		{
			size, err := m.PodRunInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *JobRunRunning) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobRunRunning) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobRunRunning) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RunInfo != nil {
		{
			size := m.RunInfo.Size()
			i -= size
			if _, err := m.RunInfo.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.JobId) > 0 {
		i -= len(m.JobId)
		copy(dAtA[i:], m.JobId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.JobId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RunId) > 0 {
		i -= len(m.RunId)
		copy(dAtA[i:], m.RunId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.RunId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *JobRunRunning_PodRunInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobRunRunning_PodRunInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PodRunInfo != nil {
		{
			size, err := m.PodRunInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *PodRunInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PodRunInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PodRunInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PodNamespace) > 0 {
		i -= len(m.PodNamespace)
		copy(dAtA[i:], m.PodNamespace)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.PodNamespace)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.PodName) > 0 {
		i -= len(m.PodName)
		copy(dAtA[i:], m.PodName)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.PodName)))
		i--
		dAtA[i] = 0x2a
	}
	if m.PodNumber != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.PodNumber))
		i--
		dAtA[i] = 0x20
	}
	if len(m.NodeName) > 0 {
		i -= len(m.NodeName)
		copy(dAtA[i:], m.NodeName)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.NodeName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.KubernetesId) > 0 {
		i -= len(m.KubernetesId)
		copy(dAtA[i:], m.KubernetesId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.KubernetesId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ClusterId) > 0 {
		i -= len(m.ClusterId)
		copy(dAtA[i:], m.ClusterId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.ClusterId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *JobRunReturned) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobRunReturned) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobRunReturned) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Reason != nil {
		{
			size := m.Reason.Size()
			i -= size
			if _, err := m.Reason.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.JobId) > 0 {
		i -= len(m.JobId)
		copy(dAtA[i:], m.JobId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.JobId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RunId) > 0 {
		i -= len(m.RunId)
		copy(dAtA[i:], m.RunId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.RunId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *JobRunReturned_LeaseExpired_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobRunReturned_LeaseExpired_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LeaseExpired != nil {
		{
			size, err := m.LeaseExpired.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *JobRunReturned_JobPreempted_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobRunReturned_JobPreempted_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.JobPreempted != nil {
		{
			size, err := m.JobPreempted.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *JobRunReturned_LeaseExpired) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobRunReturned_LeaseExpired) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobRunReturned_LeaseExpired) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *JobRunReturned_JobPreempted) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobRunReturned_JobPreempted) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobRunReturned_JobPreempted) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *JobRunSucceeded) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobRunSucceeded) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobRunSucceeded) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.JobId) > 0 {
		i -= len(m.JobId)
		copy(dAtA[i:], m.JobId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.JobId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RunId) > 0 {
		i -= len(m.RunId)
		copy(dAtA[i:], m.RunId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.RunId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *JobRunFailed) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobRunFailed) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobRunFailed) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Reason != nil {
		{
			size := m.Reason.Size()
			i -= size
			if _, err := m.Reason.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.JobId) > 0 {
		i -= len(m.JobId)
		copy(dAtA[i:], m.JobId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.JobId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RunId) > 0 {
		i -= len(m.RunId)
		copy(dAtA[i:], m.RunId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.RunId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *JobRunFailed_ApplicationFailed_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobRunFailed_ApplicationFailed_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ApplicationFailed != nil {
		{
			size, err := m.ApplicationFailed.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *JobRunFailed_OomKilled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobRunFailed_OomKilled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.OomKilled != nil {
		{
			size, err := m.OomKilled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *JobRunFailed_ApplicationFailed) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobRunFailed_ApplicationFailed) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobRunFailed_ApplicationFailed) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Error) > 0 {
		i -= len(m.Error)
		copy(dAtA[i:], m.Error)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Error)))
		i--
		dAtA[i] = 0x22
	}
	if m.Code != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x18
	}
	if len(m.JobId) > 0 {
		i -= len(m.JobId)
		copy(dAtA[i:], m.JobId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.JobId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RunId) > 0 {
		i -= len(m.RunId)
		copy(dAtA[i:], m.RunId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.RunId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *JobRunFailed_OOMKilled) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobRunFailed_OOMKilled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobRunFailed_OOMKilled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func encodeVarintEvents(dAtA []byte, offset int, v uint64) int {
	offset -= sovEvents(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *EventSequence) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Queue)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.JobSetName)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.JobSetHash)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.UserId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if len(m.Groups) > 0 {
		for _, s := range m.Groups {
			l = len(s)
			n += 1 + l + sovEvents(uint64(l))
		}
	}
	if len(m.Events) > 0 {
		for _, e := range m.Events {
			l = e.Size()
			n += 1 + l + sovEvents(uint64(l))
		}
	}
	return n
}

func (m *EventSequence_Event) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Event != nil {
		n += m.Event.Size()
	}
	return n
}

func (m *EventSequence_Event_SubmitJob) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SubmitJob != nil {
		l = m.SubmitJob.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *EventSequence_Event_ReprioritiseJob) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReprioritiseJob != nil {
		l = m.ReprioritiseJob.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *EventSequence_Event_ReprioritiseJobSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReprioritiseJobSet != nil {
		l = m.ReprioritiseJobSet.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *EventSequence_Event_CancelJob) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CancelJob != nil {
		l = m.CancelJob.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *EventSequence_Event_CancelJobSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CancelJobSet != nil {
		l = m.CancelJobSet.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *EventSequence_Event_JobSucceeded) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.JobSucceeded != nil {
		l = m.JobSucceeded.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *EventSequence_Event_JobFailed) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.JobFailed != nil {
		l = m.JobFailed.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *EventSequence_Event_JobRejected) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.JobRejected != nil {
		l = m.JobRejected.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *EventSequence_Event_JobRunLeased) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.JobRunLeased != nil {
		l = m.JobRunLeased.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *EventSequence_Event_JobRunAssigned) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.JobRunAssigned != nil {
		l = m.JobRunAssigned.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *EventSequence_Event_JobRunRunning) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.JobRunRunning != nil {
		l = m.JobRunRunning.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *EventSequence_Event_JobRunReturned) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.JobRunReturned != nil {
		l = m.JobRunReturned.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *EventSequence_Event_JobRunSucceeded) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.JobRunSucceeded != nil {
		l = m.JobRunSucceeded.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *EventSequence_Event_JobRunFailed) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.JobRunFailed != nil {
		l = m.JobRunFailed.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *SubmitJob) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.JobId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.DeduplicationId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.Priority != 0 {
		n += 9
	}
	if m.Fragile {
		n += 2
	}
	if m.ObjectMeta != nil {
		l = m.ObjectMeta.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.MainObject != nil {
		l = m.MainObject.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	if len(m.Objects) > 0 {
		for _, e := range m.Objects {
			l = e.Size()
			n += 1 + l + sovEvents(uint64(l))
		}
	}
	return n
}

func (m *KubernetesMainObject) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Object != nil {
		n += m.Object.Size()
	}
	return n
}

func (m *KubernetesMainObject_PodSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PodSpec != nil {
		l = m.PodSpec.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *KubernetesObject) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ObjectMeta != nil {
		l = m.ObjectMeta.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.Object != nil {
		n += m.Object.Size()
	}
	return n
}

func (m *KubernetesObject_PodSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PodSpec != nil {
		l = m.PodSpec.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *KubernetesObject_Ingress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ingress != nil {
		l = m.Ingress.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *KubernetesObject_Service) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Service != nil {
		l = m.Service.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *KubernetesObject_ConfigMap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConfigMap != nil {
		l = m.ConfigMap.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *ObjectMeta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if len(m.Annotations) > 0 {
		for k, v := range m.Annotations {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovEvents(uint64(len(k))) + 1 + len(v) + sovEvents(uint64(len(v)))
			n += mapEntrySize + 1 + sovEvents(uint64(mapEntrySize))
		}
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovEvents(uint64(len(k))) + 1 + len(v) + sovEvents(uint64(len(v)))
			n += mapEntrySize + 1 + sovEvents(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *PodSpecWithAvoidList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PodSpec != nil {
		l = m.PodSpec.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	if len(m.NodeAvoidlist) > 0 {
		for _, s := range m.NodeAvoidlist {
			l = len(s)
			n += 1 + l + sovEvents(uint64(l))
		}
	}
	return n
}

func (m *ReprioritiseJob) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.JobId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.Priority != 0 {
		n += 9
	}
	return n
}

func (m *ReprioritiseJobSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Priority != 0 {
		n += 9
	}
	return n
}

func (m *CancelJob) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.JobId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *CancelJobSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *JobSucceeded) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.JobId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *JobFailed) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.JobId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.Reason != nil {
		n += m.Reason.Size()
	}
	return n
}

func (m *JobFailed_MaxRunsExceeded_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MaxRunsExceeded != nil {
		l = m.MaxRunsExceeded.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *JobFailed_MaxRunsExceeded) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *JobRejected) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.JobId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.Reason != nil {
		n += m.Reason.Size()
	}
	return n
}

func (m *JobRejected_JobUnschedulable_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.JobUnschedulable != nil {
		l = m.JobUnschedulable.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *JobRejected_JobUnschedulable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *JobRunLeased) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RunId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.JobId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.ExecutorId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *JobRunAssigned) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RunId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.JobId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.RunInfo != nil {
		n += m.RunInfo.Size()
	}
	return n
}

func (m *JobRunAssigned_PodRunInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PodRunInfo != nil {
		l = m.PodRunInfo.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *JobRunRunning) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RunId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.JobId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.RunInfo != nil {
		n += m.RunInfo.Size()
	}
	return n
}

func (m *JobRunRunning_PodRunInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PodRunInfo != nil {
		l = m.PodRunInfo.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *PodRunInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClusterId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.KubernetesId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.NodeName)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.PodNumber != 0 {
		n += 1 + sovEvents(uint64(m.PodNumber))
	}
	l = len(m.PodName)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.PodNamespace)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *JobRunReturned) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RunId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.JobId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.Reason != nil {
		n += m.Reason.Size()
	}
	return n
}

func (m *JobRunReturned_LeaseExpired_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LeaseExpired != nil {
		l = m.LeaseExpired.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *JobRunReturned_JobPreempted_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.JobPreempted != nil {
		l = m.JobPreempted.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *JobRunReturned_LeaseExpired) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *JobRunReturned_JobPreempted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *JobRunSucceeded) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RunId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.JobId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *JobRunFailed) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RunId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.JobId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.Reason != nil {
		n += m.Reason.Size()
	}
	return n
}

func (m *JobRunFailed_ApplicationFailed_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApplicationFailed != nil {
		l = m.ApplicationFailed.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *JobRunFailed_OomKilled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OomKilled != nil {
		l = m.OomKilled.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *JobRunFailed_ApplicationFailed) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RunId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.JobId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.Code != 0 {
		n += 1 + sovEvents(uint64(m.Code))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *JobRunFailed_OOMKilled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func sovEvents(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozEvents(x uint64) (n int) {
	return sovEvents(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *EventSequence) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSequence: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSequence: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Queue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Queue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobSetName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobSetName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobSetHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobSetHash = append(m.JobSetHash[:0], dAtA[iNdEx:postIndex]...)
			if m.JobSetHash == nil {
				m.JobSetHash = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Groups", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Groups = append(m.Groups, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Events", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Events = append(m.Events, &EventSequence_Event{})
			if err := m.Events[len(m.Events)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSequence_Event) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Event: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Event: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubmitJob", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SubmitJob{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &EventSequence_Event_SubmitJob{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReprioritiseJob", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ReprioritiseJob{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &EventSequence_Event_ReprioritiseJob{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReprioritiseJobSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ReprioritiseJobSet{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &EventSequence_Event_ReprioritiseJobSet{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CancelJob", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CancelJob{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &EventSequence_Event_CancelJob{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CancelJobSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CancelJobSet{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &EventSequence_Event_CancelJobSet{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobSucceeded", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &JobSucceeded{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &EventSequence_Event_JobSucceeded{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobFailed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &JobFailed{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &EventSequence_Event_JobFailed{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobRejected", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &JobRejected{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &EventSequence_Event_JobRejected{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobRunLeased", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &JobRunLeased{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &EventSequence_Event_JobRunLeased{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobRunAssigned", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &JobRunAssigned{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &EventSequence_Event_JobRunAssigned{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobRunRunning", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &JobRunRunning{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &EventSequence_Event_JobRunRunning{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobRunReturned", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &JobRunReturned{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &EventSequence_Event_JobRunReturned{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobRunSucceeded", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &JobRunSucceeded{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &EventSequence_Event_JobRunSucceeded{v}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobRunFailed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &JobRunFailed{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &EventSequence_Event_JobRunFailed{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubmitJob) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubmitJob: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubmitJob: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeduplicationId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeduplicationId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Priority = float64(math.Float64frombits(v))
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fragile", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Fragile = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjectMeta == nil {
				m.ObjectMeta = &ObjectMeta{}
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MainObject", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MainObject == nil {
				m.MainObject = &KubernetesMainObject{}
			}
			if err := m.MainObject.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Objects", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Objects = append(m.Objects, &KubernetesObject{})
			if err := m.Objects[len(m.Objects)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KubernetesMainObject) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KubernetesMainObject: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KubernetesMainObject: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PodSpecWithAvoidList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Object = &KubernetesMainObject_PodSpec{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KubernetesObject) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KubernetesObject: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KubernetesObject: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjectMeta == nil {
				m.ObjectMeta = &ObjectMeta{}
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PodSpecWithAvoidList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Object = &KubernetesObject_PodSpec{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ingress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1beta1.IngressSpec{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Object = &KubernetesObject_Ingress{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Service", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1.ServiceSpec{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Object = &KubernetesObject_Service{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1.ConfigMap{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Object = &KubernetesObject_ConfigMap{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ObjectMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObjectMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObjectMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEvents
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowEvents
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthEvents
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthEvents
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowEvents
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthEvents
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthEvents
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipEvents(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthEvents
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Annotations[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEvents
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowEvents
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthEvents
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthEvents
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowEvents
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthEvents
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthEvents
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipEvents(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthEvents
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PodSpecWithAvoidList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PodSpecWithAvoidList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PodSpecWithAvoidList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PodSpec == nil {
				m.PodSpec = &v1.PodSpec{}
			}
			if err := m.PodSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeAvoidlist", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeAvoidlist = append(m.NodeAvoidlist, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReprioritiseJob) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReprioritiseJob: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReprioritiseJob: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Priority = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReprioritiseJobSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReprioritiseJobSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReprioritiseJobSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Priority = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CancelJob) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CancelJob: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CancelJob: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CancelJobSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CancelJobSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CancelJobSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobSucceeded) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobSucceeded: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobSucceeded: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobFailed) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobFailed: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobFailed: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRunsExceeded", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &JobFailed_MaxRunsExceeded{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Reason = &JobFailed_MaxRunsExceeded_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobFailed_MaxRunsExceeded) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MaxRunsExceeded: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MaxRunsExceeded: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobRejected) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobRejected: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobRejected: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobUnschedulable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &JobRejected_JobUnschedulable{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Reason = &JobRejected_JobUnschedulable_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobRejected_JobUnschedulable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobUnschedulable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobUnschedulable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobRunLeased) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobRunLeased: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobRunLeased: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RunId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecutorId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExecutorId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobRunAssigned) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobRunAssigned: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobRunAssigned: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RunId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodRunInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PodRunInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RunInfo = &JobRunAssigned_PodRunInfo{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobRunRunning) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobRunRunning: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobRunRunning: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RunId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodRunInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PodRunInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RunInfo = &JobRunRunning_PodRunInfo{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PodRunInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PodRunInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PodRunInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KubernetesId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KubernetesId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodNumber", wireType)
			}
			m.PodNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PodNumber |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PodName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodNamespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PodNamespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobRunReturned) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobRunReturned: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobRunReturned: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RunId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaseExpired", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &JobRunReturned_LeaseExpired{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Reason = &JobRunReturned_LeaseExpired_{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobPreempted", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &JobRunReturned_JobPreempted{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Reason = &JobRunReturned_JobPreempted_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobRunReturned_LeaseExpired) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LeaseExpired: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LeaseExpired: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobRunReturned_JobPreempted) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobPreempted: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobPreempted: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobRunSucceeded) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobRunSucceeded: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobRunSucceeded: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RunId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobRunFailed) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobRunFailed: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobRunFailed: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RunId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplicationFailed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &JobRunFailed_ApplicationFailed{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Reason = &JobRunFailed_ApplicationFailed_{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OomKilled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &JobRunFailed_OOMKilled{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Reason = &JobRunFailed_OomKilled{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobRunFailed_ApplicationFailed) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApplicationFailed: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApplicationFailed: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RunId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobRunFailed_OOMKilled) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OOMKilled: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OOMKilled: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipEvents(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthEvents
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupEvents
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthEvents
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthEvents        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowEvents          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupEvents = fmt.Errorf("proto: unexpected end of group")
)

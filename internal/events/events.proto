syntax = 'proto3';
package events;

import "k8s.io/api/core/v1/generated.proto";
import "k8s.io/api/networking/v1beta1/generated.proto";

// Compiling requires that the following go packages are available on the local system:
// k8s.io/api v0.22.4
// k8s.io/apimachinery v0.22.4
//
// Compile with the following commands (run from the project root directory):
// mkdir -p ./build/proto/k8s.io/api/
// mkdir -p ./build/proto/k8s.io/apimachinery/
// cp -a $(go env GOPATH)/pkg/mod/k8s.io/api@v0.22.4/* ./build/proto/k8s.io/api/
// cp -a $(go env GOPATH)/pkg/mod/k8s.io/apimachinery@v0.22.4/* ./build/proto/k8s.io/apimachinery/
// protoc -I=./build/proto -I=. --go_out=. --go_opt=paths=source_relative internal/events/events.proto --go_opt=Mk8s.io/apimachinery/pkg/api/resource/generated.proto=k8s.io/apimachinery/pkg/api/resource --go_opt=Mk8s.io/apimachinery/pkg/runtime/generated.proto=k8s.io/apimachinery/pkg/runtime --go_opt=Mk8s.io/apimachinery/pkg/runtime/schema/generated.proto=k8s.io/apimachinery/pkg/runtime/schema --go_opt=Mk8s.io/apimachinery/pkg/apis/meta/v1/generated.proto=k8s.io/apimachinery/pkg/apis/meta/v1 --go_opt=Mk8s.io/apimachinery/pkg/util/intstr/generated.proto=k8s.io/apimachinery/pkg/util/intstr --go_opt=Mk8s.io/api/core/v1/generated.proto=k8s.io/api/core/v1 --go_opt=Mk8s.io/api/networking/v1beta1/generated.proto=k8s.io/api/networking/v1beta1

// Armada state transition model
//
// The central concepts are:
// - Jobs (i.e., a request for Armada to run a particular application).
//   Each job consists of a set of Kubernetes resources (e.g., one or more pod specs, a service, and an ingress).
//   One resource is labeled the main resource, and the job is considered to have finished when that resource exits.
//   Each job is part of exactly one job set.
// - Job sets (i.e., a set of jobs that can be controlled and monitored as a unit).
//   Each job set has a unique user-supplied name, which is namespaced by queue.
//   Job sets are implicit in the sense that they consist of all jobs submitted with the same job set name.
// - Job runs (i.e., an attempt by Armada to run a particular job).
//   There may be several job runs associated with each job, representing multiple attempts to run the job.
//
// This is the sequence of operations associated with running a set of jobs in Armada:
// 1. Submit a job, which is composed of a set of Kubernetes resources. The request must include a job set name.
//    Armada returns a job id. Repeat this step to run multiple jobs in the same set.
// 2. Each job is added to Armada's queue. For each job, once it reaches the front of the queue
//    it is leased to an executor (of which there may be many), which is responsible for running the job
//    in a Kubernetes cluster. Executors map one-to-one to Kubernetes clusters.
// 3. The executor attempts to run the job. Each such attempt is referred to as a job run.
//    There may be several job runs associated with a job (e.g., if a run failed).
// 4. Armada will report the exit status of each job as they finish.
//
// The state transition model of each job is:
// [pending <=> leased => succeeded, failed]
//
// The state transition rules for each job are:
// - After being submitted, the job is pending until it has been leased to an executor by the scheduler.
// - The job transitions to the failed state if it cannot be leased to an executor
//   (e.g., if the job requests more resources than what is available in any cluster).
// - The job is in the leased state while it is leased to at least one executor.
// - The job transitions from leased to succeeded if all runs have finished and at least one succeeded
//   (i.e., the application exited with a zero exit code).
// - The job transitions from leased to pending if all runs failed and the error is considered recoverable
//   (e.g., if the pod was preempted).
// - The job transitions from leased to failed if all runs failed and the error is considered non-recoverable
 //  (e.g., if the the application exited with a non-zero exit code).
//
// The state transition model of each job run is:
// [pending => assigned => running => succeeded, failed]
//
// The state transition rules for each job run are:
// - Each job run starts when the job is assigned to an executor (by the scheduler),
//   at which point it is in the pending state.
// - While in the pending state, the executor attempts to assign the job to a node,
//   at which point the run transitions to the assigned state.
// - The run transitions to the running state once the application is running on the node it was assigned to.
// - From the running state, the run transitions to either the succeeded or failed state
//   (depending on the application exit code).
// - The run may transition to the failed state from any of the other states
//   (e.g., due to a lease expiry or due to being preempted).

// Message representing a sequence of state transitions.
// This is the only message type that should ever be published to the log.
message EventSequence {
    // List of possible events, i.e., state transitions.
    message Event {
        oneof event {
            SubmitJob submitJob = 1;
            ReprioritiseJob reprioritiseJob = 2;
            ReprioritiseJobSet reprioritiseJobSet = 3;
            CancelJob cancelJob = 4;
            CancelJobSet cancelJobSet = 5;
            JobSucceeded jobSucceeded = 6;
            JobErrors jobErrors = 7;
            JobRunLeased jobRunLeased = 8;
            JobRunAssigned jobRunAssigned= 9;
            JobRunRunning jobRunRunning= 10;
            JobRunSucceeded jobRunSucceeded = 11;
            JobRunErrors jobRunErrors = 12;
        }
    }
    // The system is namespaced by queue, and all events are associated with a job set.
    // Hence, these are included with every message.
    //
    // For efficiency, if a message has already been published to the log for a particular pair (queue, job_set_name),
    // then queue and job_set_name can be omitted from subsequent messages in favour of queue_job_set_hash,
    // which is the sha256 checksum of the concatenation of the queue and job set name.
    //
    // Because the hash is typically much shorter, doing so can significantly reduce message size.
    // Further, querying databases by the hash is typically more efficient than by (queue, job_set_name)
    // since file paths are often used for job_set_name, which often contain long common prefixes.
    //
    // The subscriber is responsible for storing previously seen combinations of (queue, job_set_name)
    // and looking those up based on their hash (i.e., content-based addressing).
    string queue = 1;
    // Each job set has a unique name.
    string job_set_name = 2;
    // sha256 of the concatenation of queue and job_set_name.
    bytes queue_job_set_hash = 3;
    // Id of the user submitting the message. Is passed on to Kubernetes.
    // Leave empty for messages generated by Armada itself.
    string user_id = 4;
    // List of groups the user is member of. Is passed on to Kubernetes.
    repeated string groups = 5;
    // For efficiency, we bundle several events (i.e., state transitions) in a single log message.
    repeated Event events = 6;
}

// A UUID, encoded in accordance with section 4.1.2 of RFC 4122
// (technically equivalent to ITU-T Rec. X.667 and ISO/IEC 9834-8).
// As of March 2022, this seems to be the most efficient way to include UUIDs in proto messages; see
// https://github.com/protocolbuffers/protobuf/issues/2224#issuecomment-760635430
message Uuid {
	// The high 64 bits of the UUID - MSB -> LSB: time_low (32 bits) | time_mid (16 bits) | time_hi_and_version (16 bits).
	fixed64 high64 = 1;
	// The low 64 bits of the UUID - MSB -> LSB: clock_seq_hi_and_reserved (8 bits) | clock_seq_low (8 bits) | node (48 bits).
	fixed64 low64 = 2;
}

// A request to run an Armada job. Each job consists of a set of Kubernetes objects,
// one of which is the main object (typically a pod spec.) and has a priority associated with it.
// When the main object exits, all other objects are cleaned up.
// The priority, together with the queue the job is submitted to, determines the order in which jobs are run.
message SubmitJob {
    // Each application may be run multiple times. This id uniquely identifies this job.
    Uuid job_id = 1;
    // User-provided id used for server-side deduplication.
    // I.e., jobs submitted with the same deduplication_id as an existing job are discarded.
    // TODO: If we can deduplicate at the API endpoint, we don't need this on the log.
    string deduplication_id = 2;
    // Priority of this job. Measured relative to other jobs in the same queue.
    uint32 priority = 3;
    // Information about how the job should be run in Kubernetes.
    // Is applied to the main object and any additional objects that do not contain a separate ObjectMeta object.
    ObjectMeta objectMeta = 4;
    // Main object that determines when an application has finished.
    KubernetesMainObject mainObject = 5;
    // Set of additional Kubernetes objects to create as part of the job.
    repeated KubernetesObject objects = 6;
    // Maximum lifetime of the job in seconds. Zero indicates an infinite lifetime.
    uint32 lifetime = 7;
    // If true, the job is run at most once, i.e., at most one job run will be created for it.
    // If false, the job may be re-leased on failure, which may cause the job to run more than once
    // (e.g., if a job run succeeds but the executor fails before it can report job success).
    bool atMostOnce = 8;
    // If true, Armada may preempt the job while running.
    bool preemptible  = 9;
    // If true, Armada may optimistically run several instances of the job concurrently
    // (typically on different clusters).
    // If false, a new job run may only be created once Armada is certain that all existing runs have finished.
    bool concurrencySafe = 10;
}

// Kubernetes objects that can serve as main objects for an Armada job.
message KubernetesMainObject {
    oneof object {
        PodSpecWithAvoidList pod_spec = 1;
    }
}

// Kubernetes objects that can be created as part of an Armada.
message KubernetesObject {
    ObjectMeta objectMeta = 1;
    oneof object {
        PodSpecWithAvoidList pod_spec = 2;
        k8s.io.api.networking.v1beta1.IngressSpec ingress = 3;
        k8s.io.api.core.v1.ServiceSpec service = 4;
        k8s.io.api.core.v1.ConfigMap configMap = 5;
    }
}

// Auxiliary information needed to instantiate the object in Kubernetes.
// Inspired by the Kubernetes ObjectMeta object; see:
// https://github.com/kubernetes/apimachinery/blob/master/pkg/apis/meta/v1/generated.proto#L641
//
// TODO: Consider including the executor id.
message ObjectMeta {
    string namespace = 1;
    string name = 2;
    // Unique id assigned to the object by Kubernetes (typically a 128-bit UUID).
    // Should be left empty on job creation, but should be set, e.g., when in the JobRunRunning message.
    // Stored as a string because Kubernetes doesn't always use UUIDs; see
    // https://github.com/kubernetes/apimachinery/blob/master/pkg/types/uid.go#L19
    string kubernetesId = 3;
    map<string, string> annotations = 4;
    map<string, string> labels = 5;
}

// Kubernetes pod spec. with a bundled list of pods to avoid scheduling the pod to.
message PodSpecWithAvoidList {
    k8s.io.api.core.v1.PodSpec pod_spec = 1;
    // List of nodes to avoid scheduling this pod on.
    // TODO: Could this be done with selectors, taints, etc?
    repeated string node_avoidlist = 2;
}

// Set the priority of a particular job.
message ReprioritiseJob {
    Uuid job_id = 1;
    uint32 priority = 2;
}

// Set the priority of all jobs part of a job set.
// This sets the priority of all jobs in the job set currently in the queued state.
message ReprioritiseJobSet {
    uint32 priority = 1;
}

// A request to cancel a particular job.
// This will cancel all runs (preempting it if running) for the job (i.e., move them to the failed state)
// and then cancel job itself (i.e., move it to the failed state).
message CancelJob {
    Uuid job_id = 1;
}

// Request to cancel all jobs in a job set.
message CancelJobSet {
}

message JobSucceeded {
    Uuid job_id = 1;
}

// Indicates that a job has been leased to a cluster by the Armada scheduler.
message JobRunLeased {
    Uuid run_id = 1;
    Uuid job_id = 2;
    // Each cluster is represented by an executor.
    string executor_id = 3;
}

// Indicates that a job has been assigned to nodes by Kubernetes.
message JobRunAssigned {
    Uuid run_id = 1;
    Uuid job_id = 2;
}

// Indicates that the resources required by the job have been created and that the job is now running.
message JobRunRunning {
    Uuid run_id = 1;
    Uuid job_id = 2;
    // Runtime information, e.g., which node the job is running on, its IP address etc,
    // for each resource created for the job run.
    repeated KubernetesResourceInfo resourceInfos = 3;
}

// Message containing runtime information about some resource created for a job.
message KubernetesResourceInfo {
    ObjectMeta objectMeta = 1;
    oneof info {
        PodInfo podInfo = 2;
    }
}

// Container for runtime information of a podspec.
message PodInfo {
    string node_name = 1;
    // TODO: Do we need this?
    int32 pod_number = 2;
}

message IngressInfo {
    // TODO: Why a node name?
    string node_name = 1;
    // TODO: Why a map?
    map<int32, string> ingress_addresses = 2;
}

// Indicates that the job finished successfully (i.e., in the expected manner).
message JobRunSucceeded {
    Uuid run_id = 1;
    Uuid job_id = 2;
}

// Message containing a set of errors associated with a particular job.
// Contains a flag, which if set to true indicates that the job has failed.
// Otherwise, this message represents a set of errors from which the system has recovered.
message JobErrors {
    Uuid job_id = 1;
    // If true, this set of errors represent an unrecoverable failure,
    // which means that Armada has given up on this job and will not create more runs for it.
    bool terminal = 2;
    // A set of errors that occurred within some context.
    repeated Error errors = 3;
}

// Message containing a set of errors associated with a particular job run.
// Contains a flag, which if set to true indicates that the job run has failed.
// Otherwise, this message represents a set of errors from which the system has recovered.
//
// Because each error may specify a parent error, the set of errors form a tree.
//
// Services may listen for these messages to obtain realtime information about errors associated with jobs.
message JobRunErrors {
    Uuid run_id = 1;
    Uuid job_id = 2;
    // If true, this set of errors represent an unrecoverable failure and the executor has given up on this job run.
    bool terminal = 3;
    // A set of errors that occurred within some context.
    repeated Error errors = 4;
}

// Represents a failure that took place in the course of a job run (i.e., an attempt to run a job).
// Each failure is either a resource failure or a system-level failure.
// Resource failures correspond to a problem with a specific Kubernetes resource
// (e.g., if a container terminates with a non-zero exit code).
// System-level failure messages are created by the executor (e.g., a failure by the executor to write to Kubernetes).
//
// This message may only be published to the log as part of a JobRunError message.
// TODO: Check if the container status contained any useful info for non-failed containers.
message Error {
	// The status code, which should be an enum value of [google.rpc.Code][google.rpc.Code].
	int32 code = 1;
	// A developer-facing error message
	string message = 2;
	// If this error is associated with a particular Kubernetes resource,
	// this ObjectMeta identifies that resource. Otherwise, this field is nil.
    ObjectMeta objectMeta = 3;
    // Any subsequent errors caused by this error.
    repeated Error child_errors = 4;
    // Additional information for this particular combination of component and error. May be set to nil.
    oneof reason {
        KubernetesError kubernetesError = 5;
        ApplicationError applicationError = 6;
        ExecutorError executorError = 7;
        JobUnschedulable jobUnschedulable = 8;
        LeaseExpired leaseExpired = 9;
        JobPreempted jobPreempted = 10;
        MaxRunsExceeded maxRunsExceeded = 11;
    }
}

// Represents an error associated with a particular Kubernetes resource.
message KubernetesError {
    // Type of Kubernetes resource (e.g., ingress).
    string resourceType = 1;
    // Id assigned to the resource by Kubernetes.
    Uuid resourceId = 2;
}

message ApplicationError {
    // Id assigned by Kubernetes to the container running the application.
    Uuid container_id = 1;
    // Exit code of the application running in the container.
    int32 code = 2;
    // Error message returned by the application in the container.
    string message = 3;
}

message ExecutorError {
}

message JobUnschedulable {
    string message = 1;
}

message LeaseExpired {
}

message JobPreempted {
}

message MaxRunsExceeded {
}